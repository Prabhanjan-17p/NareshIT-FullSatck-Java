âœ… Assignment: Injecting Dependencies Using @Qualifier in Spring Java-Based Configuration
__________________________________________________________________________________________
ðŸ“š Objective:
------------------------
Understand how to use @Qualifier to resolve ambiguity when multiple 
beans of the same type exist in a Spring Java-based configuration setup using @Configuration and @Bean.

ðŸ“ Requirements:
------------------------
> Create a University class with a constructor that takes the university name.
> Create a Student class that depends on a University instance (constructor injection).
> Define two University beans in a Java-based configuration class using @Bean, with different names:
> One named "delhiUniversity" with the value "Delhi University"
> Another named "oxfordUniversity" with the value "Oxford University"
> Use the @Qualifier annotation to inject the delhiUniversity bean into the Student class.

Define a MainApp class to:
---------------------------
Load the Spring context

|- Retrieve the Student bean
|- Call a method that prints:


Output:
____________________________________
Student belongs to: Delhi University

ðŸ”§ Constraints:
_____________________________________
|- Use Java-based Spring configuration (@Configuration and @Bean)

|- First use @component and @Autowire annotations for getting the requirement and then try 
   with below requirement
    |- Do not use @Component or @Autowired annotations

|- Use constructor injection with @Qualifier

Output must exactly match:
Student belongs to: Delhi University

âœ… Expected Output:

Student belongs to: Delhi University

ðŸ’¡ Hint:
______________________________________
Use the @Qualifier("beanName") annotation in both the configuration class and in the constructor parameter to specify which bean to inject when multiple candidates exist.

ANS -----
package com.nit.sbean;

public class Student {
	private University university;

	public Student(University university) {
		super();
		this.university = university;
	}

	public void showUniversity() {
		System.out.println("Student belongs to: " + university.getUniversityName());
	}
}


package com.nit.sbean;

import org.springframework.stereotype.Component;

@Component
public class University {
	private String name;

	public University(String name) {
		super();
		this.name = name;
	}
	
	public String getUniversityName() {
		return this.name;
	}
	
}


package com.nit.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

import com.nit.sbean.Student;
import com.nit.sbean.University;

@Configuration
public class AppConfig {
	@Bean
	public University delhiUniversity() {
		return new University("Delhi University");
	}

	@Bean
	public University oxfordUniversity() {
		return new University("Oxford University");
	}

	@Bean
	public Student student(@Qualifier("delhiUniversity") University university) {
		return new Student(university);
	}
}


package com.nit.main;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.nit.config.AppConfig;
import com.nit.sbean.Student;

public class Main {
	public static void main(String[] args) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

		Student student = context.getBean(Student.class);
		student.showUniversity();
		context.close();
	}
}

_________________________________________________________________________________
Que-2
______________
âœ… Assignment: Calculate Profit Using @Component and @Autowired in Spring
----------------------------------------------------------------------------
ðŸ“š Objective:
---------------------
Understand how to use Spring annotations such as @Component, @Autowired, 
and @ComponentScan for automatic bean detection and dependency injection.

ðŸ“ Problem Statement:
----------------------
You are building a simple Spring-based application to calculate profit based on a product's cost price and selling price. You are required to use annotation-based configuration only (no XML) to manage the application context and dependency injection.

ðŸ”§ Requirements:
-----------------------
> Create a class named Product in the package com.product:
> Annotate it with @Component.
> Provide two methods:
> public int getCostPrice() â€“ returns 100 or as per your choice
> public int getSellingPrice() â€“ returns 150 or as per your choice
> Create a class named ProfitLoss in the package com.finance:
> Annotate it with @Component.
> Inject the Product bean using @Autowired.
> Create a method public void calculateProfit() that:
> Computes the profit as: sellingPrice - costPrice

Prints the result as:
Profit: 50

Create a configuration class named AppConfig:
______________________________________________
> Annotate it with @Configuration
> Use @ComponentScan to scan both com.product and com.finance packages

In the main application, load the Spring context using AnnotationConfigApplicationContext,
retrieve the ProfitLoss bean, and call its calculateProfit() method.

ðŸš€ Expected Output:
    Profit: 50

ðŸ’¡ Hint:
    |- Use @ComponentScan(basePackages = {"com.product", "com.finance"}) to ensure both packages are scanned.
    |- Use @Autowired for field injection inside the ProfitLoss class.

ANS --
package com.product;

import org.springframework.stereotype.Component;

@Component
public class Product {
	public int getCostPrice() {
		return 100;
	}
	
	public int getSellingPrice() {
		return 150;
	}
}


package com.nit.main;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.finance.ProfitLoss;
import com.nit.config.AppConfig2;

public class Main2 {
	public static void main(String[] args) {
		try (AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig2.class);){
			ProfitLoss pl = ctx.getBean(ProfitLoss.class);
			pl.calculateProfit();
		} catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
		}
	}
}

package com.nit.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = {"com.product", "com.finance"})
public class AppConfig2 {

}


package com.finance;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.product.Product;

@Component
public class ProfitLoss {
	
	@Autowired
	private Product product;
	
	public void calculateProfit() {
		System.out.println("Profit: "+(product.getSellingPrice() - product.getCostPrice()));
		;
	}
}

__________________________________________________________________________________________
Que-3
_________________
ðŸ“ Problem Statement:
_______________________________
You are tasked with creating a simple Spring application that models a Library holding a Book. 
You need to configure Spring beans programmatically and inject dependencies using constructor injection.

ðŸ”§ Requirements:
__________________________
Create a class named Book:
|- It should have a method public String getTitle() that returns the title of the book (e.g., "Spring in Action").
|- Create a class named Library:
|- It should have a constructor that accepts a Book object.
|- It should have a method public void showBook() that prints the bookâ€™s title in the format:

Library has: Spring in Action

> Create a Spring configuration class named AppConfig:
> Annotate the class with @Configuration.

Define two beans using @Bean:
____________________________________________
A Book bean that returns a new instance of Book.

A Library bean that injects the Book bean via constructor.

In the main application, load the Spring context using 
AnnotationConfigApplicationContext, retrieve the Library bean, and call its showBook() method.

âœ… Expected Output:
-----------------------------
Library has: Spring in Action

ðŸ’¡ Hint:
|- Use constructor injection to provide the Book bean to the Library bean.
|- Use Java-based configuration (@Configuration and @Bean) instead of XML or component scanning.

ANS ---
package com.nit.main;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import com.book.Library;
import com.nit.config.AppConfig3;

public class Main3 {
	public static void main(String[] args) {
		try (AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig3.class);){
			Library lib = ctx.getBean(Library.class);
			lib.showBook();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

package com.nit.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

import com.book.Book;
import com.book.Library;

@Configuration
@ComponentScan(basePackages = "com.book")
public class AppConfig3 {

	@Bean
	public Book book() {
		return new Book();
	}

	@Bean
	public Library library() {
		return new Library(book());
	}
}


package com.book;

public class Library {
	private Book book;

	public Library(Book book) {
		super();
		this.book = book;
	}
	
	public void showBook() {
		System.out.println("Book Title :: "+book.getTitle());
	}
}

package com.book;

public class Book {
	public String getTitle() {
		return "Spring in Action";
	}
}
_________________________________________________________________________________