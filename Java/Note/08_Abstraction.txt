Abstraction [Hiding the complexity]
------------------------------------
If we display only the essential details without showing the background details (complexity) then it is called Abstraction.

Example : Electric switch board(Internal Details), ATM , LIFT
 
In java, We can achieve abstraction by using the following two concepts :

 1) Abstract class and abstract method [Partial Abstraction, 0 to 100%]
 2) Interface (Full Abstraction, 100%)
	  

Abstract class and abstract methods :
-------------------------------------------
A class that does not provide complete implementation (partial implementation) is defined as an abstract class.

An abstract method is a common method which is used to provide easiness to the programmer because the programmer faces complexcity to remember the method name.

An abstract method observation is very simple because every abstract method contains abstract keyword, abstract method does not contain any method body and at the end there must be a terminator i.e ; (semicolon)

In java, whenever action is common but implementations are different then we should use abstract method, Generally we declare abstract method in the super class and its implementation must be provided in the sub classes.

if a class contains at least one method as an abstract method then we should compulsory declare that class as an abstract class.

Once a class is declared as an abstract class we can't create an object for that class.

*All the abstract methods declared in the super class must be overridden in the sub classes otherwise the sub class will become as an abstract class hence object can't be created for the sub class as well.

In an abstract class we can write all abstract method or all concrete method or combination of both the method. 

It is used to acheive partial abstraction that means by using abstract classes we can acheive partial abstraction(0-100%).

*An abstract class may or may not have abstract method but an abstract method must have abstract class.

Note :- We can't declare an abstract method as final, private and static (illegal combination of modifiers)

We can't declare an abstract class as a final.

------------------------------------------------------------------------
//Program that describes an abstract class may contain only concrete methdos 

abstract class Hello
{
	public void m2()
	{
	}
	
}

public class AbstractTest 
{
	public static void main(String[] args) 
	{
		System.out.println("Hello World!");
	}
}
------------------------------------------------------------------------
//Program that describes how to override abstract method in the sub classes  

abstract class Shape
{
	public abstract void draw();
}
class Rectangle extends Shape
{
	@Override
	public void draw()
	{
		System.out.println("Drawing Rectangle");
	}	
}
class Square extends Shape
{
	@Override
	public void draw()
	{
		System.out.println("Drawing Square");
	}	
}
class Circle extends Shape
{
	@Override
	public void draw()
	{
		System.out.println("Drawing Circle");
	}
}

public class AbstractDemo1 
{
	public static void main(String[] args) 
	{
		Shape s = null;
		
		s = new Rectangle(); s.draw();
		s = new Square(); s.draw();
		s = new Circle(); s.draw();
	}
}
-----------------------------------------------------------------------
The following program explains that we can execute the constructor of abstract class from sub class object by using super().

package com.ravi.abstract_demo;

abstract class Bike
{
	protected int speed = 80;
	
	public Bike()
	{
		System.out.println("Bike class constructor...");
	}
	
	public void bikeDetails()
	{
		System.out.println("It has two wheels...");
	}
	
	public abstract void run();
	
}
class KTM extends  Bike
{
	
	@Override
	public void run() 
	{
	   System.out.println("KTM bike is running");		
	}	
}
public class InterviewQuestion 
{
	public static void main(String[] args) 
	{
        Bike bike = new KTM();
        System.out.println("Bike Speed is :"+bike.speed);
        bike.bikeDetails();
        bike.run();
	}

}
----------------------------------------------------------------------
Q) If we are unable to create an object for abstract class than what is the advantage of writing constructor in the abstract class and how non static variable of abstract class gets memory ? 

We can't create an Object for abstract class but if we write any constructor in the abstract class then it will be executed by using sub class object with the help of super().

Due to constructor chaining, abstract class constructor will be executed hence memory will be allocated for non static variables.
[26-March-25]
-----------------------------------------------------------------------
//Program that describes overriding abstract method is compulsory in the sub classes otherwise sub class will also become as abstract class.

package com.ravi.abstract_demo;

abstract class Alpha
{
	public abstract void show();
	public abstract void demo();
}

abstract class Beta extends Alpha
{
	@Override
	public void show() //+ demo();
	{
		System.out.println("Show method implemented in Beta class");		
	}	
}
class Gamma extends Beta
{
	@Override
	public void demo() 
	{
		System.out.println("Demo method is implemented in Gamma class");		
	}	
}

public class AbstractDemo
{
	public static void main(String[] args) 
	{
		Gamma g = new Gamma();
		g.show();
		g.demo();

	}

}
----------------------------------------------------------------------
Program that describes abstract method is just like business rule so every sub class should implement that rule to exist in the real world.

package com.ravi.abstract_demo;

abstract class Animal
{
	protected String name;
	
	public Animal(String name) 
	{
		super();
		this.name = name;
	}
	public abstract void checkup();
}
class Lion extends Animal
{
	public Lion(String name)
	{
		super(name);
	}	
	
	@Override
	public void checkup()
	{
	  System.out.println(name+" is going for checkup");			
	}
	
}
class Bird extends Animal
{
	public Bird(String name)
	{
		super(name);
	}	
	
	@Override
	public void checkup()
	{
	  System.out.println(name+" is going for checkup");			
	}
	
}
class Dog extends Animal
{
	public Dog(String name)
	{
		super(name);
	}	
	
	@Override
	public void checkup()
	{
	  System.out.println(name+" is going for checkup");			
	}	
}

public class AbstractAnimalRule {

	public static void main(String[] args) 
	{
		Lion lions[] = {new Lion("A"), new Lion("B"), new Lion("Simba")};
		Bird birds[] = {new Bird("Parrot"),new Bird("Koyal")};
		Dog dogs[] = {new Dog("Tommy"), new Dog("Tiger")};	
		
		animalCheckup(lions);
		animalCheckup(birds);
		animalCheckup(dogs);

	}
	
	public static void animalCheckup(Animal []animals)
	{
		for(Animal animal : animals)
		{
			animal.checkup();
		}
		System.out.println("...............");
	}
	

}
-----------------------------------------------------------------------
27-03-2025
-----------
Anonymos inner class :
---------------------
If we declare a class inside a method body without any class name then it is called Anonymous inner class.

The main purpose of anonymous inner class to extend a super class or to implement an interface that means for creating sub type. 
[Anonymous inner class is only used for creating the sub type]

Anonymous inner class declaration and Object creation by using new keyword both will be done in a single line i.e single statement.

An inner class .class file is represented by $ symbol.

//Program on Anonymous inner class 

package com.ravi.anonymous_inner_class;

class Vehicle
{
	public void run()
	{
		System.out.println("Generic Vehicle is running");
	}
}

public class AnonymousInnerDemo1
{
	public static void main(String[] args) 
	{
       //Anonymous inner class		
	   Vehicle car	= new Vehicle()
       {
		   @Override
		   public void run()
		   {
			   System.out.println("Car is running");
		   }	   
	   };
	   
	   Vehicle bike	= new Vehicle()
       {
		   @Override
		   public void run()
		   {
			   System.out.println("Bike is running");
		   }	   
	   };
	      
	   car.run();
	   bike.run();
	}

}

Note : For Anonymous inner class compiler will generate AnonymousInnerDemo1$1.class and AnonymousInnerDemo1$2.class
-----------------------------------------------------------------------
Anonymous inner class with abstract method implementation :
----------------------------------------------------------
package com.ravi.anonymous_inner_class;

abstract class RBI
{
	public abstract void provideLoan();
}

public class AnonymousInnerDemo2 
{
	public static void main(String[] args) 
	{
		RBI icici = new RBI()
		{			
			@Override
			public void provideLoan() 
			{
				System.out.println("ICICI bank loan interest is 9.2%");				
			}			
		};
		
		RBI hdfc = new RBI()
		{			
			@Override
			public void provideLoan() 
			{
				System.out.println("HDFC bank loan interest is 9.1%");				
			}			
		};
		
		icici.provideLoan();   hdfc.provideLoan();

	}
}
=======================================================================
28-03-2025
-----------
Interface :
-----------
interface upto java 1.7
------------------------
An interface is a keyword in java which is similar to a class which defines working functionality of a class.

Upto JDK 1.7 an interface contains only abstract methods that means there is a guarantee that inside an interfcae we don't have concrete or general or instance methods.

From java 8 onwards we have a facility to write default and static methods.

By using interface we can achieve 100% abstraction concept because it contains only abstract methods.

In order to implement the member of an interface, java software people has provided implements keyword.

All the methods declared inside an interface is by default public and abstract so at the time of overriding we can't reduce the accessibility level.

All the variables declared inside an interface is by default public, static and final.

We should override all the abstract methods of interface to the sub classes otherwise the sub class will become as an abstract class hence object can't be created.

We can't create an object for interface, but reference can be created.

By using interface we can acheive multiple inheritance in java.

We can achieve loose coupling using interface.

Note :- inside an interface we can't declare any blocks (instance, static), instance variables (No properties) as well as we can't write constructor inside an interface.
-----------------------------------------------------------------------
Interface Programs :
--------------------
package com.ravi.interface_ex;

sealed interface Moveable permits Car
{
	int SPEED = 100; //public + static + final [static blank final field]
	
	void move();  //public + abstract
}
final class Car implements Moveable
{
	@Override
	public void move()
	{
	   //SPEED = 100;  [Invalid]
		System.out.println("Speed of the Car is :"+SPEED);
	}	
}

public class InterfaceDemo1 
{
	public static void main(String[] args) 
	{
       Moveable moveable = new Car();
       moveable.move();
       System.out.println("Car is running with "+Moveable.SPEED+" Speed");
	}

}
-----------------------------------------------------------------------
interface Vehicle    
{
	void run();	
}
public class InterfaceDemo2  
{
	public static void main(String[] args) 
	{   
	   Vehicle car = new Vehicle()
	   {
		   @Override
		   public void run()
		   {
			   System.out.println("Car is Running");
		   }
	   };
	   
	   car.run();
	   
	   
	}

}

----------------------------------------------------------------------
package com.ravi.interface_ex;

interface Bank
{
	void deposit(double amount);
	void withdraw(double amount);
}

class Customer implements Bank
{
	private double balance = 10000;

	@Override
	public void deposit(double amount) 
	{
		if(amount <=0)
		{
			System.out.println("Deposit is not possible");
			System.exit(0);
		}
		this.balance = this.balance + amount;
		System.out.println("Amount after deposit :"+this.balance);
	}

	@Override
	public void withdraw(double amount) 
	{
	   if(amount > this.balance)
	   {
		   System.out.println("Withdraw is not possible");
		   System.exit(0);
	   }
	   this.balance = this.balance - amount;
	   System.out.println("Amount after withdraw is :"+this.balance);
	}
}
public class InterfaceDemo3 
{
	public static void main(String[] args)
	{
        Bank bank = new Customer();	
        bank.deposit(12000);
        bank.withdraw(50000);
	}

}
-----------------------------------------------------------------------
//Program on loose coupling :
------------------------------
Program on loose coupling : (Industry Standard Program)
--------------------------------------------------------
Loose Coupling :- If the degree of dependency from one class object to another class is very low then it is called loose coupling. [interface is reqd]

Tightly coupled :- If the degree of dependency of one class to another class is very high then it is called Tightly coupled.

According to IT industry standard we should always prefer loose coupling so the maintenance of the project will become easy.

High Cohesion [Encapsulation]:
------------------------------
Our private data must be accessible via public methods (setter and getters) so, in between data and method we must have high cohesion.
(tight coupling) so, validation of outer data is possible.

6 files :
---------
package com.ravi.loose_coupling;

public interface HotDrink 
{
  void prepare();
}

package com.ravi.loose_coupling;

public class Tea implements HotDrink 
{
	@Override
	public void prepare()
	{
		System.out.println("Preparing Tea");
	}
}

package com.ravi.loose_coupling;

public class Coffee implements HotDrink 
{
	@Override
	public void prepare() 
	{
		System.out.println("Preparing Coffee");
	}
}

package com.ravi.loose_coupling;

public class ExpressTea implements HotDrink {

	@Override
	public void prepare() 
	{
	  System.out.println("Premimum Tea is preparing");	
	}

}


package com.ravi.loose_coupling;

public class Restaurant 
{
   public static void prepareHotDrink(HotDrink hd) //hd =  
   {
	   hd.prepare();
   }
}

package com.ravi.loose_coupling;

public class LooseCoupling 
{
	public static void main(String[] args)
	{
		Restaurant.prepareHotDrink(new Tea());
		Restaurant.prepareHotDrink(new Coffee());
		Restaurant.prepareHotDrink(new ExpressTea());

	}
}

Note : Taking interface as a method parameter is a very good option which provides loose coupling and we can inject any type of Object to the interface, the only thing is that class must implements from that particular interface.

return type of a Mthod can be interface :
------------------------------------------
We also take return type of the method as an interface so we can have lot of option to return different kind of Object.

public HotDrink accept()
{
    return new Tea();  OR return new Coffee();
}
----------------------------------------------------------------------
01-04-2025
-----------
Another Program on interface :
-------------------------------
package com.ravi.interface_demo;

interface Calculator
{
	void add(double x, double y);
	void sub(double x, double y);
	void mul(double x, double y);
}

class ArithmeticOperation implements Calculator
{
	
	@Override
	public void add(double x, double y)
	{
		System.out.println("Sum is :"+(x+y));
		
	}

	@Override
	public void sub(double x, double y) 
	{
		System.out.println("Sub is :"+(x-y));
		
	}

	@Override
	public void mul(double x, double y)
	{
		System.out.println("Mul is :"+(x*y));
		
	}
	
}
public class InterfaceCalculation {

	public static void main(String[] args) 
	{
		Calculator calc = new ArithmeticOperation();
		calc.add(23, 89);
		calc.sub(23, 89);
		calc.mul(2, 8);
	}
}
---------------------------------------------------------------------
How can we achieve multiple inheritanec using interface :
----------------------------------------------------------
interface never contains any constructor so the implementer class constructor will directly call the Object class Constructor hence multiple Inheritance is possible in java [01-APR-25]

package com.ravi.interface_demo;

interface A
{
	void m1();
}
interface B
{
	void m1();	
}

class C implements A,B
{
	@Override
	public void m1() 
	{
		System.out.println("M1 method Overridden");		
	}	
}
public class MultipleInheritance {

	public static void main(String[] args) 
	{
		C c1 = new C();
		c1.m1();
	}

}
---------------------------------------------------------------------
Can we exetend OR implement an interface ?
-------------------------------------------
One interface can extends another interface, It cannot implement, implementation means we need to provid the body for abstract method.

package com.ravi.interface_demo;

interface Alpha
{
	void m1();
}
interface Beta extends Alpha
{
	void m2();
}

class Implementer implements Beta
{
	@Override
	public void m1() 
	{
		System.out.println("M1 method Overridden");		
	}

	@Override
	public void m2() 
	{
		System.out.println("M2 method Overridden");		
	}	
}
public class ExtendingInterface {

	public static void main(String[] args) 
	{
		Implementer i = new Implementer();
		i.m1();  i.m2();

	}

}
======================================================================
interface from JDK 1.8V (Java 8 features) :
-------------------------------------------
Java 8V is very popular and introduced in the March 2014.

As we know upto JDK 1.7, an interface can contain only two things :
  a) public static and final variables
  b) public and abstract methods

From java 8V onwards, Java software people has provided the facility to add default and static methods (with method body) inside an interface as shown below :

interface NewFeature
{
   default void m1()  //JDK 1.8
   {
      System.out.println("Default Method"); 
   }
   
   static void m2()   //JDK 1.8
   {
     System.out.println("Static Method"); 
   }   
}

Q) Why they allowed to write method body inside an interface ?
---------------------------------------------------------------
The basic problem OR limitation with abstract method is, It must be implemented in all the implementer (sub) classes otherwise the implementer class will become as an abstract class.

It leads to big problem for industry because, If we want to add any new feature(new abstract method) to the existing interface then it must be overridden in the sub class, whether it is required OR not required ?

From JDK 1.8V, Java has provided default method facility

What is default method in java :
---------------------------------
It is allowed to write method body inside an interface in the form of default method.
Inside an interface default keyword is used to represent default method to provide default implementation.

Here It is not an access modifier.

default methods are allowed inside an interface only.

The access modifier of default method inside an interface is by default public so, at the time of overriding we can't reduce the visibility.

//Program on default method :

Vehicle.java
-------------
package com.ravi.java_8_features;

public interface Vehicle 
{		
   void run();
   void horn();
   
   default void digitalMeter() //java 8
   {
	   System.out.println("Digital Meter facility is coming soon");
   }
}

Car.java
---------
package com.ravi.java_8_features;

public class Car implements Vehicle 
{
	@Override
	public void run() 
	{
		System.out.println("Car is Running..");		
	}

	@Override
	public void horn() 
	{
		System.out.println("Car has Horn");		
	}

	 @Override
	 public void digitalMeter() 
	 {
		   System.out.println("Car has Digital Meter");
	 }
	

}

Bike.java
----------

package com.ravi.java_8_features;

public class Bike implements Vehicle 
{
	@Override
	public void run() 
	{
		System.out.println("Bike is Running..");		
	}
	
	@Override
	public void horn() 
	{
		System.out.println("Bike has Horn");		
	}
}

NewFaature.java
----------------
package com.ravi.java_8_features;

public class NewFeature
{
	public static void main(String[] args) 
	{		
        Vehicle v = null;
        v = new Car(); v.run(); v.horn(); v.digitalMeter();
        System.out.println(".................");
        v = new Bike(); v.run(); v.horn(); v.digitalMeter();
	}
}
======================================================================







