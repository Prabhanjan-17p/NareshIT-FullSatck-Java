Abstraction [Hiding the complexity]
------------------------------------
If we display only the essential details without showing the background details (complexity) then it is called Abstraction.

Example : Electric switch board(Internal Details), ATM , LIFT
 
In java, We can achieve abstraction by using the following two concepts :

 1) Abstract class and abstract method [Partial Abstraction, 0 to 100%]
 2) Interface (Full Abstraction, 100%)
	  

Abstract class and abstract methods :
-------------------------------------------
A class that does not provide complete implementation (partial implementation) is defined as an abstract class.

An abstract method is a common method which is used to provide easiness to the programmer because the programmer faces complexcity to remember the method name.

An abstract method observation is very simple because every abstract method contains abstract keyword, abstract method does not contain any method body and at the end there must be a terminator i.e ; (semicolon)

In java, whenever action is common but implementations are different then we should use abstract method, Generally we declare abstract method in the super class and its implementation must be provided in the sub classes.

if a class contains at least one method as an abstract method then we should compulsory declare that class as an abstract class.

Once a class is declared as an abstract class we can't create an object for that class.

*All the abstract methods declared in the super class must be overridden in the sub classes otherwise the sub class will become as an abstract class hence object can't be created for the sub class as well.

In an abstract class we can write all abstract method or all concrete method or combination of both the method. 

It is used to acheive partial abstraction that means by using abstract classes we can acheive partial abstraction(0-100%).

*An abstract class may or may not have abstract method but an abstract method must have abstract class.

Note :- We can't declare an abstract method as final, private and static (illegal combination of modifiers)

We can't declare an abstract class as a final.

------------------------------------------------------------------------
//Program that describes an abstract class may contain only concrete methdos 

abstract class Hello
{
	public void m2()
	{
	}
	
}

public class AbstractTest 
{
	public static void main(String[] args) 
	{
		System.out.println("Hello World!");
	}
}
------------------------------------------------------------------------
//Program that describes how to override abstract method in the sub classes  

abstract class Shape
{
	public abstract void draw();
}
class Rectangle extends Shape
{
	@Override
	public void draw()
	{
		System.out.println("Drawing Rectangle");
	}	
}
class Square extends Shape
{
	@Override
	public void draw()
	{
		System.out.println("Drawing Square");
	}	
}
class Circle extends Shape
{
	@Override
	public void draw()
	{
		System.out.println("Drawing Circle");
	}
}

public class AbstractDemo1 
{
	public static void main(String[] args) 
	{
		Shape s = null;
		
		s = new Rectangle(); s.draw();
		s = new Square(); s.draw();
		s = new Circle(); s.draw();
	}
}
-----------------------------------------------------------------------
The following program explains that we can execute the constructor of abstract class from sub class object by using super().

package com.ravi.abstract_demo;

abstract class Bike
{
	protected int speed = 80;
	
	public Bike()
	{
		System.out.println("Bike class constructor...");
	}
	
	public void bikeDetails()
	{
		System.out.println("It has two wheels...");
	}
	
	public abstract void run();
	
}
class KTM extends  Bike
{
	
	@Override
	public void run() 
	{
	   System.out.println("KTM bike is running");		
	}	
}
public class InterviewQuestion 
{
	public static void main(String[] args) 
	{
        Bike bike = new KTM();
        System.out.println("Bike Speed is :"+bike.speed);
        bike.bikeDetails();
        bike.run();
	}

}
----------------------------------------------------------------------
Q) If we are unable to create an object for abstract class than what is the advantage of writing constructor in the abstract class and how non static variable of abstract class gets memory ? 

We can't create an Object for abstract class but if we write any constructor in the abstract class then it will be executed by using sub class object with the help of super().

Due to constructor chaining, abstract class constructor will be executed hence memory will be allocated for non static variables.
[26-March-25]
-----------------------------------------------------------------------
//Program that describes overriding abstract method is compulsory in the sub classes otherwise sub class will also become as abstract class.

package com.ravi.abstract_demo;

abstract class Alpha
{
	public abstract void show();
	public abstract void demo();
}

abstract class Beta extends Alpha
{
	@Override
	public void show() //+ demo();
	{
		System.out.println("Show method implemented in Beta class");		
	}	
}
class Gamma extends Beta
{
	@Override
	public void demo() 
	{
		System.out.println("Demo method is implemented in Gamma class");		
	}	
}

public class AbstractDemo
{
	public static void main(String[] args) 
	{
		Gamma g = new Gamma();
		g.show();
		g.demo();

	}

}
----------------------------------------------------------------------
Program that describes abstract method is just like business rule so 
every sub class should implement that rule to exist in the real world.

package com.ravi.abstract_demo;

abstract class Animal
{
	protected String name;
	
	public Animal(String name) 
	{
		super();
		this.name = name;
	}
	public abstract void checkup();
}
class Lion extends Animal
{
	public Lion(String name)
	{
		super(name);
	}	
	
	@Override
	public void checkup()
	{
	  System.out.println(name+" is going for checkup");			
	}
	
}
class Bird extends Animal
{
	public Bird(String name)
	{
		super(name);
	}	
	
	@Override
	public void checkup()
	{
	  System.out.println(name+" is going for checkup");			
	}
	
}
class Dog extends Animal
{
	public Dog(String name)
	{
		super(name);
	}	
	
	@Override
	public void checkup()
	{
	  System.out.println(name+" is going for checkup");			
	}	
}

public class AbstractAnimalRule {

	public static void main(String[] args) 
	{
		Lion lions[] = {new Lion("A"), new Lion("B"), new Lion("Simba")};
		Bird birds[] = {new Bird("Parrot"),new Bird("Koyal")};
		Dog dogs[] = {new Dog("Tommy"), new Dog("Tiger")};	
		
		animalCheckup(lions);
		animalCheckup(birds);
		animalCheckup(dogs);

	}
	
	public static void animalCheckup(Animal []animals)
	{
		for(Animal animal : animals)
		{
			animal.checkup();
		}
		System.out.println("...............");
	}
	

}
-----------------------------------------------------------------------
27-03-2025
-----------
Anonymos inner class :
---------------------
If we declare a class inside a method body without any class name then it is called Anonymous inner class.

The main purpose of anonymous inner class to extend a super class or to implement an interface that means for creating sub type. 
[Anonymous inner class is only used for creating the sub type]

Anonymous inner class declaration and Object creation by using new keyword both will be done in a single line i.e single statement.

An inner class .class file is represented by $ symbol.

//Program on Anonymous inner class 

package com.ravi.anonymous_inner_class;

class Vehicle
{
	public void run()
	{
		System.out.println("Generic Vehicle is running");
	}
}

public class AnonymousInnerDemo1
{
	public static void main(String[] args) 
	{
       //Anonymous inner class		
	   Vehicle car	= new Vehicle()
       {
		   @Override
		   public void run()
		   {
			   System.out.println("Car is running");
		   }	   
	   };
	   
	   Vehicle bike	= new Vehicle()
       {
		   @Override
		   public void run()
		   {
			   System.out.println("Bike is running");
		   }	   
	   };
	      
	   car.run();
	   bike.run();
	}

}

Note : For Anonymous inner class compiler will generate AnonymousInnerDemo1$1.class and AnonymousInnerDemo1$2.class
-----------------------------------------------------------------------
Anonymous inner class with abstract method implementation :
----------------------------------------------------------
package com.ravi.anonymous_inner_class;

abstract class RBI
{
	public abstract void provideLoan();
}

public class AnonymousInnerDemo2 
{
	public static void main(String[] args) 
	{
		RBI icici = new RBI()
		{			
			@Override
			public void provideLoan() 
			{
				System.out.println("ICICI bank loan interest is 9.2%");				
			}			
		};
		
		RBI hdfc = new RBI()
		{			
			@Override
			public void provideLoan() 
			{
				System.out.println("HDFC bank loan interest is 9.1%");				
			}			
		};
		
		icici.provideLoan();   hdfc.provideLoan();

	}
}
=======================================================================
28-03-2025
-----------
Interface :
-----------
interface upto java 1.7
------------------------
An interface is a keyword in java which is similar to a class which defines working functionality of a class.

Upto JDK 1.7 an interface contains only abstract methods that means there is a guarantee that inside an interfcae we don't have concrete or general or instance methods.

From java 8 onwards we have a facility to write default and static methods.

By using interface we can achieve 100% abstraction concept because it contains only abstract methods.

In order to implement the member of an interface, java software people has provided implements keyword.

All the methods declared inside an interface is by default public and abstract so at the time of overriding we can't reduce the accessibility level.

All the variables declared inside an interface is by default public, static and final.

We should override all the abstract methods of interface to the sub classes otherwise the sub class will become as an abstract class hence object can't be created.

We can't create an object for interface, but reference can be created.

By using interface we can acheive multiple inheritance in java.

We can achieve loose coupling using interface.

Note :- inside an interface we can't declare any blocks (instance, static), instance variables (No properties) as well as we can't write constructor inside an interface.
-----------------------------------------------------------------------
Interface Programs :
--------------------
package com.ravi.interface_ex;

sealed interface Moveable permits Car
{
	int SPEED = 100; //public + static + final [static blank final field]
	
	void move();  //public + abstract
}
final class Car implements Moveable
{
	@Override
	public void move()
	{
	   //SPEED = 100;  [Invalid]
		System.out.println("Speed of the Car is :"+SPEED);
	}	
}

public class InterfaceDemo1 
{
	public static void main(String[] args) 
	{
       Moveable moveable = new Car();
       moveable.move();
       System.out.println("Car is running with "+Moveable.SPEED+" Speed");
	}

}
-----------------------------------------------------------------------
interface Vehicle    
{
	void run();	
}
public class InterfaceDemo2  
{
	public static void main(String[] args) 
	{   
	   Vehicle car = new Vehicle()
	   {
		   @Override
		   public void run()
		   {
			   System.out.println("Car is Running");
		   }
	   };
	   
	   car.run();
	   
	   
	}

}

----------------------------------------------------------------------
package com.ravi.interface_ex;

interface Bank
{
	void deposit(double amount);
	void withdraw(double amount);
}

class Customer implements Bank
{
	private double balance = 10000;

	@Override
	public void deposit(double amount) 
	{
		if(amount <=0)
		{
			System.out.println("Deposit is not possible");
			System.exit(0);
		}
		this.balance = this.balance + amount;
		System.out.println("Amount after deposit :"+this.balance);
	}

	@Override
	public void withdraw(double amount) 
	{
	   if(amount > this.balance)
	   {
		   System.out.println("Withdraw is not possible");
		   System.exit(0);
	   }
	   this.balance = this.balance - amount;
	   System.out.println("Amount after withdraw is :"+this.balance);
	}
}
public class InterfaceDemo3 
{
	public static void main(String[] args)
	{
        Bank bank = new Customer();	
        bank.deposit(12000);
        bank.withdraw(50000);
	}

}
-----------------------------------------------------------------------
//Program on loose coupling :
------------------------------
Program on loose coupling : (Industry Standard Program)
--------------------------------------------------------
Loose Coupling :- If the degree of dependency from one class object to another class is very low then it is called loose coupling. [interface is reqd]

Tightly coupled :- If the degree of dependency of one class to another class is very high then it is called Tightly coupled.

According to IT industry standard we should always prefer loose coupling so the maintenance of the project will become easy.

High Cohesion [Encapsulation]:
------------------------------
Our private data must be accessible via public methods (setter and getters) so, in between data and method we must have high cohesion.
(tight coupling) so, validation of outer data is possible.

6 files :
---------
package com.ravi.loose_coupling;

public interface HotDrink 
{
  void prepare();
}

package com.ravi.loose_coupling;

public class Tea implements HotDrink 
{
	@Override
	public void prepare()
	{
		System.out.println("Preparing Tea");
	}
}

package com.ravi.loose_coupling;

public class Coffee implements HotDrink 
{
	@Override
	public void prepare() 
	{
		System.out.println("Preparing Coffee");
	}
}

package com.ravi.loose_coupling;

public class ExpressTea implements HotDrink {

	@Override
	public void prepare() 
	{
	  System.out.println("Premimum Tea is preparing");	
	}

}


package com.ravi.loose_coupling;

public class Restaurant 
{
   public static void prepareHotDrink(HotDrink hd) //hd =  
   {
	   hd.prepare();
   }
}

package com.ravi.loose_coupling;

public class LooseCoupling 
{
	public static void main(String[] args)
	{
		Restaurant.prepareHotDrink(new Tea());
		Restaurant.prepareHotDrink(new Coffee());
		Restaurant.prepareHotDrink(new ExpressTea());

	}
}

Note : Taking interface as a method parameter is a very good option which provides loose coupling and we can inject any type of Object to the interface, the only thing is that class must implements from that particular interface.

return type of a Mthod can be interface :
------------------------------------------
We also take return type of the method as an interface so we can have lot of option to return different kind of Object.

public HotDrink accept()
{
    return new Tea();  OR return new Coffee();
}
----------------------------------------------------------------------
01-04-2025
-----------
Another Program on interface :
-------------------------------
package com.ravi.interface_demo;

interface Calculator
{
	void add(double x, double y);
	void sub(double x, double y);
	void mul(double x, double y);
}

class ArithmeticOperation implements Calculator
{
	
	@Override
	public void add(double x, double y)
	{
		System.out.println("Sum is :"+(x+y));
		
	}

	@Override
	public void sub(double x, double y) 
	{
		System.out.println("Sub is :"+(x-y));
		
	}

	@Override
	public void mul(double x, double y)
	{
		System.out.println("Mul is :"+(x*y));
		
	}
	
}
public class InterfaceCalculation {

	public static void main(String[] args) 
	{
		Calculator calc = new ArithmeticOperation();
		calc.add(23, 89);
		calc.sub(23, 89);
		calc.mul(2, 8);
	}
}
---------------------------------------------------------------------
How can we achieve multiple inheritanec using interface :
----------------------------------------------------------
interface never contains any constructor so the implementer class constructor will directly call the Object class Constructor hence multiple Inheritance is possible in java [01-APR-25]

package com.ravi.interface_demo;

interface A
{
	void m1();
}
interface B
{
	void m1();	
}

class C implements A,B
{
	@Override
	public void m1() 
	{
		System.out.println("M1 method Overridden");		
	}	
}
public class MultipleInheritance {

	public static void main(String[] args) 
	{
		C c1 = new C();
		c1.m1();
	}

}
---------------------------------------------------------------------
Can we exetend OR implement an interface ?
-------------------------------------------
One interface can extends another interface, It cannot implement, implementation means we need to provid the body for abstract method.

package com.ravi.interface_demo;

interface Alpha
{
	void m1();
}
interface Beta extends Alpha
{
	void m2();
}

class Implementer implements Beta
{
	@Override
	public void m1() 
	{
		System.out.println("M1 method Overridden");		
	}

	@Override
	public void m2() 
	{
		System.out.println("M2 method Overridden");		
	}	
}
public class ExtendingInterface {

	public static void main(String[] args) 
	{
		Implementer i = new Implementer();
		i.m1();  i.m2();

	}

}
======================================================================
interface from JDK 1.8V (Java 8 features) :
-------------------------------------------
Java 8V is very popular and introduced in the March 2014.

As we know upto JDK 1.7, an interface can contain only two things :
  a) public static and final variables
  b) public and abstract methods

From java 8V onwards, Java software people has provided the facility to add default and static methods (with method body) inside an interface as shown below :

interface NewFeature
{
   default void m1()  //JDK 1.8
   {
      System.out.println("Default Method"); 
   }
   
   static void m2()   //JDK 1.8
   {
     System.out.println("Static Method"); 
   }   
}

Q) Why they allowed to write method body inside an interface ?
---------------------------------------------------------------
The basic problem OR limitation with abstract method is, It must be implemented in all the implementer (sub) classes otherwise the implementer class will become as an abstract class.

It leads to big problem for industry because, If we want to add any new feature(new abstract method) to the existing interface then it must be overridden in the sub class, whether it is required OR not 
required ?

From JDK 1.8V, Java has provided default method facility

What is default method in java :
---------------------------------
It is allowed to write method body inside an interface in the form of default method.

Inside an interface default keyword is used to represent default method to provide "default implementation".

Here It is not an access modifier.

default methods are allowed inside an interface only.

The access modifier of default method inside an interface is by default public so, at the time of overriding we can't reduce the visibility.

//Program on default method :

Vehicle.java
-------------
package com.ravi.java_8_features;

public interface Vehicle 
{		
   void run();
   void horn();
   
   default void digitalMeter() //java 8
   {
	   System.out.println("Digital Meter facility is coming soon");
   }
}

Car.java
---------
package com.ravi.java_8_features;

public class Car implements Vehicle 
{
	@Override
	public void run() 
	{
		System.out.println("Car is Running..");		
	}

	@Override
	public void horn() 
	{
		System.out.println("Car has Horn");		
	}

	 @Override
	 public void digitalMeter() 
	 {
		   System.out.println("Car has Digital Meter");
	 }
	

}

Bike.java
----------

package com.ravi.java_8_features;

public class Bike implements Vehicle 
{
	@Override
	public void run() 
	{
		System.out.println("Bike is Running..");		
	}
	
	@Override
	public void horn() 
	{
		System.out.println("Bike has Horn");		
	}
}

NewFaature.java
----------------
package com.ravi.java_8_features;

public class NewFeature
{
	public static void main(String[] args) 
	{		
        Vehicle v = null;
        v = new Car(); v.run(); v.horn(); v.digitalMeter();
        System.out.println(".................");
        v = new Bike(); v.run(); v.horn(); v.digitalMeter();
	}
}

Note : Unlike abstract method, default method implementation is not compulsory, If a sub class wants to override then can override to change the default implementation.
======================================================================
02-04-2025
----------
What is a static method inside an interface ?
----------------------------------------------
It is allowed to write static method with method body inside an interface from JDK 1.8V.

It is used to represent the common feature for all the classes which are going to access this static method.

By default the access modifier of static method is public.

Static method of an interface can be accessible through interface name only because the static method of an interface is limited to interface only, It is not available inside the implementer classes.

Example :
----------
public interface Callable
{
  static void call()  //static method from JDK 1.8V [by default public]
  {
  }
}  
---------------------------------------------------------------------
//Program on static method that describes static methods are by default public so we can access from another package.

package com.ravi.static_method_demo;

public interface Calculate 
{
   static double doSum(double x, double y)
   {
	   return (x+y);
   }
   
   static double getSquare(double num)
   {
	   return (num*num);
   }
}

package com.ravi.reuse;

import com.ravi.static_method_demo.Calculate;

public class Main {

	public static void main(String[] args)
	{
		double sum = Calculate.doSum(100, 200);
		System.out.println("Sum is :"+sum);
		
		double square = Calculate.getSquare(9);
		System.out.println("Square is :"+square);
	}

}
---------------------------------------------------------------------
* As we know a public static method of super class is by default available to its sub classes.

Q) Is there any difference between class static method and interface 
   static method (available from JDK 1.8)
   
Yes, We have two major differences which are as follows :

a) interface static methods are by default public.
b) interface static methods are available to interface only, It is not
   available in the implementer classes.

//Program that describes we can call static method of an interface by using only one way that is by using interface name only.

package com.ravi.static_method_demo;

public interface Callable
{
   static void call()
   {
	   System.out.println("Static Method");
   }
}

package com.ravi.static_method_demo;

public class StaticMethodDemo2  implements Callable
{
	public static void main(String[] args) 
	{		
		Callable.call();
	}
}

Points to remember :
---------------------
1) interface static methods are by default public.
2) It is not available in the implementer classes.
3) It can be accessible through interface name only.
----------------------------------------------------------------------
Program that describes we can write main method inside an interface from JDK 1.8V

package com.ravi.static_method_demo;

public interface Printable 
{
   public static void main(String[] args) 
   {
	  System.out.println("Interface main method");
   }
}
---------------------------------------------------------------------
Some points regarding default methods :
----------------------------------------
In between class and interface, class is having more priority.

In between concrete method and default method, concrete method which 
belongs to class is having more priority than default method as shown in the program.

package default_methdo_issues;

interface Alpha
{
	default void m1()
	{
		System.out.println("default method of Alpha interface...");
	}
}
class Beta
{
	public void m1()
	{
		System.out.println("Concrete method of Beta class...");
	}
}

class Gamma extends Beta implements Alpha 
{
	
}
public class Priority
{
	public static void main(String[] args) 
	{
		Gamma g = new Gamma();
		g.m1();
	}

}
=====================================================================
Can we achive multiple inheritance by using default method ?
-------------------------------------------------------------
We can achieve multiple inheritance by using default methods also because interface never contains constructor.

In order to call interface default method, we need to use super keyword with interface name as shown below :


package default_methdo_issues;

interface A
{
	default void show()
	{
		System.out.println("interface A show method");
	}
}
interface B
{
	default void show()
	{
		System.out.println("interface B show method");
	}
}
class C implements A,B
{	
	@Override
	public void show() 
	{
		A.super.show();
		B.super.show();
		System.out.println("Overridden show method");
	}	
}
public class MultipleInheritance
{
	public static void main(String[] args) 
	{
		C c1 = new C();
		c1.show();

	}

}
=====================================================================
03-04-2025
-----------
What is Functional Programming ?
---------------------------------
It is introduced from Java 8v.

In Functional Programming, First time java concentrated on functions i.e methods. 

The main purpose of learning functional programming is to reduce the length of the function OR method.

What is a Functional Interface ?
--------------------------------
If an interface contains exactly one abstract method then that interface is known as Functional interface.

It may contain 'n' numbers of default and static method but It must contain only one abstract method.

It may be represented by @FunctionalInterface annotation so the Java compiler will restrict the developer to take only one abstract method.

Example :
---------
@FunctionalInterface
interface Printable
{
	void print();  //SAM [Single Abstract Method]
	
	default void draw()
	{
	}
	
	static void m3()
	{
	}
}

Here Printable is a Functional interface because It contains only one abstract method.
---------------------------------------------------------------------
//Program on Functional Interface :
------------------------------------
package com.ravi.functional_interface;

@FunctionalInterface
interface Bird
{
   void sleep();   
}
public class FunctionalInterfaceDemo 
{
	public static void main(String[] args) 
	{
		Bird parrot = new Bird()
		{
			@Override
			public void sleep() 
			{
				System.out.println("Parrot is sleeping");				
			}			
		};

		Bird peacock = new Bird()
		{
			@Override
			public void sleep() 
			{
				System.out.println("Peacock is sleeping");				
			}			
		};
		
		parrot.sleep();
		peacock.sleep();
		
	}

}

---------------------------------------------------------------------
What is Lambda Expression in java ?
------------------------------------
It is a new feature introduced in java from JDK 1.8 onwards.
It is an anonymous function i.e function without any name.
In java it is used to enable functional programming.
It is used to concise our code as well as we can remove boilerplate code.
Lambda will work only with functional interface.
If the body of the Lambda Expression contains only one statement then curly braces are optional.
We can also remove the variables type while defining the Lambda Expression parameter.
If the lambda expression method contains only one parameter then we can remove () symbol also.

In lambda expression return keyword is optional but if we use return keyword then {} are compulsory.

Independently Lamda Expression is not a statement.

It requires a target variable i.e functional interface reference only.

Lamda target can't be class or abstract class, it will work with functional interface only. 
---------------------------------------------------------------------
package com.ravi.lambda;

interface Printable
{
	void print(); //SAM
}

public class Lambda1 {

	public static void main(String[] args) 
	{
		Printable p1 = () -> System.out.println("Printing");
		p1.print();
	}

}
--------------------------------------------------------------
package com.ravi.lambda;

@FunctionalInterface
interface Vehicle
{
	void run();
}
public class LambdaDemo2 {

	public static void main(String[] args)
	{
		Vehicle car = ()-> System.out.println("Car is running");
		Vehicle bike = ()-> System.out.println("Bike is running");
		Vehicle bus = ()-> System.out.println("Bus is running");

		car.run();
		bike.run();
		bus.run();
		
	}

}

------------------------------------------------------------------
package com.ravi.lambda;

@FunctionalInterface
interface Calculator
{
	void doSum(int x, int y);
}
public class LambdaDemo3 
{
	public static void main(String[] args) 
	{
		Calculator calc = (c,d) -> System.out.println("Sum is :"+(c+d));
		calc.doSum(12, 24);
	}

}
--------------------------------------------------------------------
package com.ravi.lambda;

interface Length
{
	public abstract int getLength(String str); 
}
public class LambdaDemo4 
{
	public static void main(String[] args) 
	{
		Length l =  str -> str.length();		
		System.out.println("Length is :"+l.getLength("Hyderabad"));
	}

}
--------------------------------------------------------------------
04-04-2025
-----------
Predefined functional interface :
----------------------------------
Java has provided predefined functional interfaces. Here we will see how to work with java.lang.Runnable predefined functional interface.

Java has provided this predefined functional interface :

@FunctionalInterface
public interface Runnable
{
   void run(); //SAM
}

//Program to work with predefined Runnable functional interfrace :
package com.ravi.functionl_interface;

public class RunnableDemo {

	public static void main(String[] args) 
	{
		Runnable r =  () -> System.out.println("Running");
		r.run();

	}

}
---------------------------------------------------------------------
What is Type Parameter<?> in java ?
------------------------------------
In java, It is represented by <T> type parameter.

It is used to make our java application independent of data type.

It also known as Generics from JDK 1.5v

In this type parameter <T> we can pass any Wrapper class, User-defined classes but we can't pass any primitive data type.

---------------------------------------------------------------------
//Program on Type Parameter

package com.ravi.type_parameter;

class Accept<T>  
{
	private T data;

	public Accept(T data) 
	{
		super();
		this.data = data;
	}

	public T getData() 
	{
		return data;
	}	
}

public class TypeParameterDemo1 {

	public static void main(String[] args) 
	{
		Accept<Integer> intType = new Accept<Integer>(12);
        System.out.println("Integer Object is :"+intType.getData());
        
        Accept<Double> dblType = new Accept<Double>(1234D);
        System.out.println("Double Object is :"+dblType.getData());
        
        Accept<Boolean> boolType = new Accept<Boolean>(true);
        System.out.println("Boolean Object is :"+boolType.getData());
        
        Accept<Student> stuType = new Accept<Student>(new Student());
        System.out.println("Student Object is :"+stuType.getData());
	}

}

class Student
{

	@Override
	public String toString() 
	{
		return "Batch 42 AND 43";
	}	
}
=====================================================================
Working with predefined functional interfaces :
-----------------------------------------------
In order to work with day to day programming and to write concise coding, java has provided predefined functional interafces which are available in java.util.function sub package.

The following are the predefined functional interfaces available in java.lang.function sub package.

1) Predicate<T>
2) Consumer<T>
3) Function<T,R>
4) Supplier<T>
5) BiPredicate<T,U>
6) BiConsumer<T,U>
7) BiFunction<T,U,R>
8) UnaryOperator<T>
9) BinaryOperator<T>
10) ToIntFunction<T>
11) ToLongFunction<T>
12) ToDoubleFunction<T>

like that we have total 43 predefined functional interfaces.

1) Predicate<T> functional interface :
--------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is mainly used to verify ONE ARGUMENT BOOLEAN EXPRESSION.

Here the lambda body must return boolean value either by using expression OR by using method.

@FunctionalInterface
public interface Predicate<T>
{
   boolean test(T x);
}

//Program on Predicate 
----------------------
package com.ravi.predicate_demo;

import java.util.Scanner;
import java.util.function.Predicate;

public class PredicateDemo1 {

	public static void main(String[] args) 
	{
		//To verify a number is even or odd
		
		Predicate<Integer> p1 =  num -> num % 2 ==0;
		
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter a number :");
		int num = sc.nextInt();		
		boolean isEven = p1.test(num);
		System.out.println(num+ " is even :"+isEven);
		sc.close();
		
		
	}

}
------------------------------------------------------------------
package com.ravi.predicate_demo;

import java.util.Scanner;
import java.util.function.Predicate;

public class PredicateDemo2 {

	public static void main(String[] args) 
	{
		// Verify whether my name starts with R or not
		
		Predicate<String> p2 = str -> str.startsWith("R");
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter your Name :");
		String name = sc.next();		
		System.out.println(name+" starts with 'R' :"+p2.test(name));
		sc.close();		
	}

}
--------------------------------------------------------------------
package com.ravi.predicate_demo;

import java.util.function.Predicate;

public class PredicateDemo3 {

	public static void main(String[] args) 
	{
	  //Verify that your name is Ravi
	
	 Predicate<String> p3 = str -> str.equalsIgnoreCase("Ravi");	
	 System.out.println("Are you Ravi :"+p3.test("ravi"));	

	}

}
---------------------------------------------------------------------
Assignment : Verify leap year, Person is eligible for Vote 
--------------------------------------------------------------------
Consumer<T> functional interface :
----------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is used to accept/consume a single value and returns nothing.

@FunctionalInterface
public interface Consumer<T>
{
   void accept(T x);
}

//Program
package com.ravi.consumer_demo;

import java.util.function.Consumer;

public class ConsumerDemo1 
{
	public static void main(String[] args) 
	{
		//Consume different values
		Consumer<Integer> conInt = num -> System.out.println(num);
		conInt.accept(12);
		
		Consumer<Float> conFloat = num -> System.out.println(num);
		conFloat.accept(19F);
		
		Consumer<Character> conChar = num -> System.out.println(num);
		conChar.accept('A');
	}

}
=====================================================================
07-04-2025
----------
Function<T,R> functional interface :
------------------------------------
It is a predefined functional interface available in java.util.function sub package.

Function takes T,R as a parameter, Here T represents input type where as R represents the return result.

In this Function<T,R> functional interface the input type <T> and the return result <R> both are decided by user.

@FunctionalInterface
public interface Function<T,R>
{
    public abstract R apply(T x);
}
---------------------------------------------------------------------
//Programs on Function<T,R> functional interface 

package com.ravi.function_demo;

import java.util.Scanner;
import java.util.function.Function;

public class FunctionDemo1 {

	public static void main(String[] args) 
	{
	  //Find the cube of the number
	  Function<Integer,Integer> fn1 = num -> num*num*num;	
	  
	  Scanner sc = new Scanner(System.in);
	  System.out.print("Enter a number :");
	  
	  int num = sc.nextInt();
	  System.out.println("Cube of :"+num+" is :"+fn1.apply(num));  
      sc.close();
	}

}
--------------------------------------------------------------------
package com.ravi.function_demo;

import java.util.Scanner;
import java.util.function.Function;

public class FunctionDemo2 {

	public static void main(String[] args) 
	{
	  //Find the length of the String
		
      Function<String,Integer> fn2 = str -> str.length();
      
      Scanner sc = new Scanner(System.in);
      System.out.print("Enter your city name :");
      String city = sc.next();
      
      System.out.println(city +" length is :"+fn2.apply(city));
      sc.close();
	}

}
---------------------------------------------------------------------
package com.ravi.function_demo;

import java.util.Scanner;
import java.util.function.Function;

public class FunctionDemo3 
{
	public static void main(String[] args) 
	{
	  //Verify the name starts with 'R' or not ?
		
	  Function<String, Boolean> fn3 = 	str -> str.startsWith("R");
	  Scanner sc = new Scanner(System.in);
      System.out.print("Enter your name :");
      String name = sc.nextLine();
      
      Boolean isValid = fn3.apply(name);
      
      System.out.println("Does your name start with 'R' "+isValid);
      sc.close();
	}

}
---------------------------------------------------------------------
4) Supplier<T> Functional interface :
-------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is used to supply/get from the lambda body.

It does not accept any parameter but return type is <T> which is decided by the user.

@FunctionalInterface
public interface Supplier<T>
{
   T get();
}
---------------------------------------------------------------------
package com.ravi.supplier;

import java.util.function.Supplier;

public class SupplierDemo1 {

	public static void main(String[] args) 
	{
		Supplier<String> s1 = ()-> 100 + 200 + "Hyd"+ 50 + 50;
		System.out.println(s1.get());
	}
}
---------------------------------------------------------------------
package com.ravi.supplier;

import java.util.function.Supplier;

class Player
{
	private int id;
	private String name;
	
	public Player(int id, String name) 
	{
		super();
		this.id = id;
		this.name = name;
	}

	@Override
	public String toString() {
		return "Player [id=" + id + ", name=" + name + "]";
	}
	
}

public class SupplierDemo2 {

	public static void main(String[] args) 
	{
		Supplier<Player> s2 = () -> new Player(18, "Virat");
		Player player = s2.get();
		System.out.println(player);
	}

}
---------------------------------------------------------------------
package com.ravi.supplier;

import java.util.Scanner;
import java.util.function.Supplier;

class Product
{
	private Integer id;
	private String name; 
	private Double price;
	
	public Product(Integer id, String name, Double price) 
	{
		super();
		this.id = id;
		this.name = name;
		this.price = price;
	}
	
	@Override
	public String toString() {
		return "Product [id=" + id + ", name=" + name + ", price=" + price + "]";
	}	
}
public class SupplierDemo3 
{
	public static void main(String[] args) 
	{
		Supplier<Product> s3 = () -> 
		{
			Scanner sc = new Scanner(System.in);
			System.out.print("Enter Product Id :");
			int id = Integer.parseInt(sc.nextLine());
			
			System.out.print("Enter Product Name :");
			String name = sc.nextLine();
			
			System.out.print("Enter Product Price :");
			double price = Double.parseDouble(sc.nextLine());			
					
			return new Product(id, name, price);
		};	
		
		Product product = s3.get();
		System.out.println(product);
		
	}

}
---------------------------------------------------------------------
Is it possible to develop our own functional interfaces with Different Parameter ?

Yes, We can develop our own Functional Interfaces with different Parameter.

package com.ravi.function_demo;

@FunctionalInterface
interface TriFunction<T,U,V,R>
{
	public abstract R applyAsFunction(T a, U b, V c);
}
public class CustomFunctionalInterface
{
	public static void main(String[] args) 
	{
		TriFunction<Integer, Integer, Integer, String>	fn1 = 
		( a ,  b,   c) ->	a +" "+b+" "+c;
		
		System.out.println(fn1.applyAsFunction(100, 200, 300));
	}

}
---------------------------------------------------------------------
BiPredicate<T,U> functional interface :
-----------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents a predicate (a boolean-valued function) OF TWO ARGUMENTS.

The BiPredicate interface has method named test, which takes two parameters and returns a boolean value, basically this BiPredicate is same with the Predicate, instead, it takes 2 arguments for the metod test.


@FunctionalInterface
public interface BiPredicate<T, U> 
{
    boolean test(T t, U u);
}

Type Parameters:

T - the type of the first argument to the predicate
U - the type of the second argument the predicate

Note : return type is boolean.

---------------------------------------------------------------------
import java.util.function.*;
public class Lambda11 
{
	public static void main(String[] args)   
    {
        BiPredicate<String, Integer> filter = (x, y) -> 
		{
            return x.length() == y;  
        };

        boolean result = filter.test("Ravi", 4);
        System.out.println(result);  

        result = filter.test("Hyderabad", 10);
        System.out.println(result);
	}
}
---------------------------------------------------------------------
import java.util.function.BiPredicate;

public class Lambda12
{
  public static void main(String[] args) 
  {
    // BiPredicate to check if the sum of two integers is even
    BiPredicate<Integer, Integer> isSumEven = (a, b) -> (a + b) % 2 == 0;

        System.out.println(isSumEven.test(2, 3));    
        System.out.println(isSumEven.test(5, 7));   
    }
}
----------------------------------------------------------------------
BiConsumer<T, U> functional interface :
---------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents an operation that accepts two input arguments and returns no result.

It takes a method named accept, which takes two parameters and performs an action without returning any result.

@FunctionalInterface
public interface BiConsumer<T, U> 
{
    void accept(T t, U u);
}
-----------------------------------------------------------------------
import java.util.function.BiConsumer;

public class Lambda13
{
   public static void main(String[] args) 
   {
     BiConsumer<Integer, String> updateVariables =  (num, str) -> 
		 {
            num = num * 2;
            str = str.toUpperCase();
            System.out.println("Updated values: " + num + ", " + str);
        };

        
        int number = 15;
        String text = "nit";

        updateVariables.accept(number, text);

        // Values after the update (note that the original values are unchanged)
        System.out.println("Original values: " + number + ", " + text);
    }
}
-----------------------------------------------------------------------
BiFunction<T, U, R> Functional interface :   
---------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents a function that accepts two arguments and produces a result R.

The BiFunction interface has a method named apply that takes two arguments and returns a result of type R.

@FunctionalInterface
public interface BiFunction<T, U, R> 
{
    R apply(T t, U u);
}
-----------------------------------------------------------------------
import java.util.function.BiFunction;

public class Lambda14
{
  public static void main(String[] args) 
  {
        // BiFunction to concatenate two strings
    BiFunction<String, String, String> concatenateStrings = (str1, str2) -> str1 + str2;

        String result = concatenateStrings.apply("Hello", " Java");
        System.out.println(result);  


      // BiFunction to find the length two strings
    BiFunction<String, String, Integer> calculateLength = (str1, str2) -> str1.length() + str2.length();

        Integer result1 = calculateLength.apply("Hello", "Java");
        System.out.println(result1);  


  }
}
-----------------------------------------------------------------------
08-04-2025
------------
UnaryOperator<T> :[Operand type<T> and return result<T> both are same type]
----------------------------------------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents an operation on a single operand that produces a result of the same type as its operand. This is a specialization of Function for the case where the operand and result are of the same type.

It has a single type parameter, T, which represents both the operand type and the result type.

@FunctionalInterface
public interface UnaryOperator<T> extends Function<T,T>
{
  public abstract T apply(T x);
}
----------------------------------------------------------------------
import java.util.function.*;
public class Lambda15  
{
	public static void main(String[] args) 
	{
		UnaryOperator<Integer> square =  x -> x*x;		
        System.out.println(square.apply(5));

		UnaryOperator<String> concat = str -> 
         str.concat("base");
		 System.out.println(concat.apply("Data"));
	}
}
-----------------------------------------------------------------------
BinaryOperator<T>
-----------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents an operation upon two operands of the same type, producing a result of the same type as the operands. 

This is a specialization of BiFunction for the case where the operands and the result are all of the same type.

It has two parameters of same type, T, which represents both the operand types and the result type.

@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T,T,T>
{
  public abstract T apply(T x, T y);
}
-----------------------------------------------------------------------
import java.util.function.*;
public class Lambda16  
{
	public static void main(String[] args) 
	{
	  BinaryOperator<Integer> add = (a, b) -> a + b;
          System.out.println(add.apply(3, 5));  
	}
}
-----------------------------------------------------------------------
Can we use all different types of variables in the lambda body ?
-----------------------------------------------------------------
Yes, we can use all different types of variable in the lambda body like static, non static and local variable.

While using the local variable in the Lambda body, the local variable must be final OR effectively final.

@FunctionalInterface
interface Drawable
{
	void draw();
}

public class LambdaBodyLocalVariable 
{
	public static void main(String[] args) 
	{
	   String shapeType = "Circle";	
	   //shapeType = "Square"; //Invalid	  
		
	  Drawable d1 =	() -> System.out.println("Drawing "+shapeType);
	  d1.draw();
	}
}
-----------------------------------------------------------------------
Does an interface extend a class :
----------------------------------
No, an interface can't extend a class, An interface can extend another interface.

In order to support upcasting concept in java, all the public and non final methods of Object class are re-declared inside an interface as an abstract method if that interface does not extend from another interface.

package com.ravi.interface_object_class;

interface Printable 
{
	
}
public class InterfaceDemo1 
{
	public static void main(String[] args) 
	{
		Printable p = null;
        p.toString();
        p.hashCode();
        p.equals(null);

	}

}
-----------------------------------------------------------------------
package com.ravi.interface_object_class;

@FunctionalInterface
interface Callable   
{
	public abstract void call();
	public abstract String toString();
	public abstract int hashCode();
	public abstract boolean equals(Object obj);
	
}
class Call extends Object implements Callable
{
	@Override
	public void call() 
	{
				
	}	
}

public class InterfaceDemo2 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
Note : java compiler will not add any final method of Object class inside an interface because abstract method we can't declare as final.
-----------------------------------------------------------------------
Can a default method of interface override/write the public method of Object class with same signature and return type.

No, a default method of an interface can't override/write the public method of Object class due to the following two reasons :
(01-JAN)

1) Ambiguity issue : Object class already contain the method which
                     interface wants to define as a default method hence it will provide Ambiguity to sub class
		     (Implementer class)


2) Priority : Concrete method is having more priority than 
              default method that means Object class method is having more priority than default method of interface so compiler will not allow to write any default method as a public method of Object class.(There is no use)
               

package com.ravi.interface_object_class;

public interface Callable 
{
  default String toString()  //error
  {
	  return "Hello";
  }
	
  default int hashCode() //error
  {
	  return 10;
  }
	
}

So, the conclusion is Object class methods we cannot write as a default method inside an interface.
-----------------------------------------------------------------------
09-04-2025
------------
Interface from JAVA 9V
----------------------
We can write private static and private non static (not public)
methods inside an interface from java 9 version.

The main purpose of providing these two methods inside an 
interface are as follows :

1) Code Reusability 
--------------------
If two or more than two default methods want to share a common code (Helper Method code) then we can write these common code in private methods so it will enhance code reusability.

2) Hide the Logic from Outer World 
----------------------------------
By writing these code in private static and private non static methods the actual logic is not visible to the outer world so, It is way to make our interface as a fully abstract class so 100% abstraction is possible.

Note : By default interface is not Fully abstract but we can make it full abstract from java 9V by writing the logic inside private method.

Note : from default method we can call private static as well as private non static methods but from public static method (java 8V) of interface we can call only private static method.
----------------------------------------------------------------------
package com.ravi.java_9;

interface Printable
{
	 int printingSpeed = 40;  //JDK 1.0
	 
	 void print();  //JDK 1.0
	 	 
	 
	 default void m1() //JDK 1.8
	 {
		 m3();
		 m4();
	 }
	 
	 default void anotherMethod()
	 {
		m3();
		m4();
	 }
	 
	 
	 static void m2() //JDK 1.8
	 {
		m4();
	 }
	 
	 private void m3() //java 9 [private non static method]
	 {
		 System.out.println("Private non static method");
	 }
	 
	 private static void m4() //java 9 [private  static method]
     {
		 System.out.println("Private static method");
	 }	 
}
class Print implements Printable
{
	@Override
	public void print() 
	{
		System.out.println("Printing Speed is :"+printingSpeed);		
	}
	
}

public class JavaNewFeatures {

	public static void main(String[] args) 
	{
		Printable p = new Print();
		System.out.println(p.toString());
		p.m1();
		Printable.m2();
	}

}
-----------------------------------------------------------------------
What is a Marker interface in java :
-------------------------------------
If an interface does not contain any field OR method, basically an empty interface OR tag interface is known as Marker Interface.

Example :
---------
public interface Drawbale  //Marker interface
{

}

Java software people has provided the following marker interface :

1) java.lang.Cloneable
2) java.io.Serializable
3) java.util.RandomAccess

* The main purpose of marker interface to provide the additional information to JVM regarding the Object.
-----------------------------------------------------------------------

 ****What is difference between abstract class and interface ?
----------------------------------------------------------------
The following are the differences between abstract class and interface.

1) An abstract class can contain instance variables but interface variables are by default public , static and final (no instance variable).

2) An abstract class can have state (properties) of an object but interface can't have state of an object.

3) An abstract class can contain constructor but inside an interface we can't define constructor.

4) An abstract class can contain instance and static blocks but inside an interface we can't define any blocks.

5) Abstract class can't refer Lambda expression but using Functional interface we can refer Lambda Expression.	

6) By using abstract class multiple inheritance is not possible but by using interface we can achieve multiple inheritance.

--------------OOPs Completed..........................................

Exception Handling :
--------------------















