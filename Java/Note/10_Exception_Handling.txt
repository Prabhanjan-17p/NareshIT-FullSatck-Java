Exception Handling :
--------------------
An exception is an abnormal situation OR un-expected situation in a normal execution flow.

Due to an exception, the execution of the program will be disturbed first and then terminated permanently.

Exception always encounter at runtime only.

Exception encounter due to the following reasons :

  1) The Wrong input given by the user.
  2) Due to dependency, When one part of the program is dependent to another part to complete the task then there might be a chance of getting an exception. 
  
Different Criteria for Exception :
-----------------------------------
1) java.lang.ArithmeticException :
----------------------------------
If we divide a number by zero (an int value) then at runtime we will get an exception i.e java.lang.ArithmeticException 

                  int x = 18; 
		  int y = 0; 
		  int z = x/y;
  
2) java.lang.ArrayIndexOutOfBoundException :
---------------------------------------------
 If we try to access the index of an array which is not available then we will get java.lang.ArrayIndexOutOfBoundsException 
  
  int []arr = {10,20};
  System.out.println(arr[3]);
  
3) java.lang.NumberFormatException
-----------------------------------
If we try to convert the String into corresponding int(primitive) OR Wrapper(Integer) and if the String is not in a numeric format then we will get runtime exception i.e java.lang.NumberFormatException. 

Case 1:
-------
String str = "NIT";
int val = Integer.parseInt(str);
System.out.println(val);
  
Case 2:
--------
String str = "India";
Integer val = Integer.valueOf(str);
System.out.println(val);  
  
4) java.lang.NullPointerException :
-----------------------------------
If any reference variable is pointing to null and by using the reference variable we are calling any non static field OR non static method then we will get java.lang.NullPointerException.

Case 1 :
--------
String str = null;
System.out.println(str.toUpperCase());

Case 2 :
---------
String s1 = "null";
System.out.println(s1.length());
System.out.println(s1.toUpperCase());

Case 3 :
---------
Scanner sc = new Scanner(System.in);
System.out.println("Enter a String value :");
String s1 = sc.nextLine(); //"null"
System.out.println(s1.length()); //4

5) java.lang.NegativeArraySizeException
---------------------------------------
Whenever we create an array, the size of the array must be positive
integer only otherwise we will get java.lang.NegativeArraySizeException

int []arr = new int[-12];

6) java.lang.StringIndexOutOfBoundsException 
---------------------------------------------
If we try to access the String index (String is character array) but if the index is out of the range then we will get 
java.lang.StringIndexOutOfBoundsException 

String str = "Hyderabad";
System.out.println(str.substring(2,-5)); 

Note : ArrayIndexOutOfBoundsException class StringIndexOutOfBoundsException class both are sub class of java.lang.IndexOutOfBoundsException.


7) java.util.InputMismatchException :
-------------------------------------
While reading the value using Scanner class, We should always read 
appropriate value other we will get java.util.InputMismatchException

Scanner sc = new Scanner(System.in);
System.out.println("Enter a number :");
int num = sc.nextInt(); //If we don't read int value then exception
System.out.println(num); 
=======================================================================
Exception Hierarchy :
---------------------
Paint Digram [10th April]

Note :- As a developer we are responsibe to handle the Exception. System admin is responsibe to handle the error because we cannot recover from error.
----------------------------------------------------------------------
Q) WAP to show that Exception is the super class of all types of 
   Exception whether it is checked Or unchecked

Ans : From the Exception Hierarchy, It is clear that java.lang.Exception is the super class for all type of Exception whether it is checked OR Unchecked.

package com.ravi.exception_demo;

import java.io.IOException;

public class ExceptionDemo 
{
	public static void main(String[] args)
	{
		Exception e1 = new ArithmeticException();
		System.out.println(e1);
		
		Exception e2 = new ArrayIndexOutOfBoundsException();
		System.out.println(e2);
		
                Exception e3 = new IOException();
                System.out.println(e3);		
	}

}
-----------------------------------------------------------------------
What is Exception Format ?
---------------------------
Whenever we print any Exception Object then the by default format is :
FUlly Qualified Name : error Message

Example :

Exception e1 = new ArithmeticException("My error message");
System.out.println(e1.toString());	

java.lang.ArithmeticException:My error message
-----------------------------------------------------------------------
WAP that desribes, whenever an exception is encounter in the 
program then our program will be terminated abnormally (halt in the middle)

package com.ravi.exception_demo;

import java.util.Scanner;

public class AbnormalTermination {

	public static void main(String[] args) 
	{
		System.out.println("Main Method started..");
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the value of x :");
		int x = sc.nextInt();
		System.out.print("Enter the value of y :");
		int y = sc.nextInt();
		
		int result = x /y;
		System.out.println("Result is :"+result);
		System.out.println("Main Method ended..");
		sc.close();		
	}

}

In the above progran, If we put the value of y as 0 then the program will halt in the middle which is known as abnormal termination.

By default, JVM has default exception handler which will handle the 
execption, terminate the program in the middle (abnormal termination)
and generate the exception message.
-----------------------------------------------------------------------
11-04-2025
----------
In order to handle the exception and to work with exception. Java software people has provided the following keywords :

1) try block
2) catch block
3) finally block [Java 1.7V, try with resourses]
4) throw keyword
5) throws keyword


try block :
-----------
Whenever our statement is error suspecting statement OR Risky statement then we should write that statement inside the try block.

try block must be followed either by catch block or finally block or both.

*try block is responsible to trace our code line by line, if any execption is encountered then with the help of JVM, TRY BLOCK WILL CREATE APPROPRIATE EXECPTION OBJECT, AND THROW THIS EXCEPTION OBJECT to the nearest catch block.

After the execption in the try block, the remaining code of try block will not be executed because control will directly transfer to the catch block.

In between try and catch block we cannot write any kind of statement.

catch block :
--------------
The main purpose of catch block to handle the exception which is thrown by try block.

catch block will only executed if there is an exception in the try block.
-----------------------------------------------------------------------
package com.ravi.exception;

import java.util.Scanner;

public class TryDemo {

	public static void main(String[] args)
	{
		 System.out.println("Main method Started!!!");
					
		   Scanner sc = null;
			try
			{
				sc = new Scanner(System.in);
				System.out.print("Enter the value of x :");
				int x = sc.nextInt();
				
				System.out.print("Enter the value of y :");
				int y = sc.nextInt();
				
				int result = x/y;
				
				System.out.println("Result is :"+result);
				System.out.println("End of try block");
			}
			catch(Exception e)
			{
				System.out.println("Inside Catch block");
				System.err.println(e);
			}			
			System.out.println("Main method Completed!!!");
			sc.close();
	}

}

In the above program if we put the value of y as 0 but still program will be executed normally because we have used try-catch so it is a 
normal termination even we have an exception in the program.
-----------------------------------------------------------------------
In case on any Exception in the try block, try block is responsible to create (with the help of JVM) exception object and throw the exception object to the nearest catch block but user can also explicitly create and throw the Exception object as shown below.

public class TryDemo 
{
	public static void main(String[] args) 
	{
		try
		{
		   throw new ArithmeticException();
		   //System.out.println(10/0);
		}
		catch(Exception e)
		{
			System.out.println("Catch Block");
			System.err.println(e);
		}
		
		System.out.println("Main Completed");
	}
}


After throw keyword we can't write any kind of statement, It 
will become un-reachable code. 
----------------------------------------------------------------------
package com.ravi.exception;

class Demo extends Throwable
{
	public Demo(String errorMessage)
	{
		super(errorMessage);
	}
}

public class ThrowableException
{
	public static void main(String[] args)
	{
		try
		{
		   throw new Demo("demo error");	
		}
		catch(Throwable e)
		{
			System.err.println(e.toString());
		}
	}

}

Note : If our Demo class does not extend from any of the Exception class OR Throwable class then this Demo Object is not a Throwable type of object hance we can't use throw keyword.
-----------------------------------------------------------------------
Without Exception Handling, If exception = Abnormal termination.
With Exception Handling, If exception = Normal Termination.

The actual use of Exception Handling :
--------------------------------------
 The main purpose of exception handling to provide user-friendly message so client can enjoy the services of software/websites.   

Exception handlinag = No Abnormal Termination + User-friendly message on wrong input given by the client.

package com.ravi.exception;

import java.util.Scanner;

public class CustomerDemo 
{
	public static void main(String[] args) 
	{
		System.out.println("Hello Client, Welcome to my Application :");
		Scanner sc = new Scanner(System.in);
		
		try
		{
			System.out.print("Please enter the value of x :");
			int x = sc.nextInt();
			System.out.print("Please enter the value of y :");
			int y = sc.nextInt();
			
			int result = x /y;
			System.out.println("Result is :"+result);
		}
		catch(Exception e)
		{
			System.err.println("Please don't put zero here");
		}
		sc.close();
		System.out.println("Thank you Client, Please Visit Again!!");
	}

}
----------------------------------------------------------------------
12-04-2025
-----------
Working with predefined non static method of Throwable class :
---------------------------------------------------------------
Throwable class has provided the following methods :
----------------------------------------------------
Throwable class has provided the following three methods :

1) public String getMessage() :- It will provide only error message.

2) public void printStackTrace() :-  It will provide the complete details regarding exception like exception class name, exception error message, exception class location, exception method name and exception line number.

3) public String toString() :- It will convert the throwable into String representation.

package com.ravi.exception;

public class ThrowableMethod {

	public static void main(String[] args) 
	{
		try
		{
			throw new ArithmeticException("Divide by zero"); 
		}
		catch(Exception e)
		{
			System.out.println(e.getMessage()); 
			System.out.println("===============");
			e.printStackTrace();
			System.out.println("===============");
			System.out.println(e.toString());
		}
	}

}
-----------------------------------------------------------------------
Working with Specific Exception :
---------------------------------
While working with exception, in the corresponding catch block we can take Exception (super class) which can handle any type of Exception.

On the other hand we can also take specific type of exception (ArithmetiException, InputMismatchException and so on) which will handle only one type i.e specific type of exception.

package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

public class SpecificException 
{
	public static void main(String[] args) 
	{
       System.out.println("Main started");
		
		Scanner sc = new Scanner(System.in);
		
		try
		{			
			System.out.print("Enter your Roll :");
			int roll = sc.nextInt();  
			System.out.println("Your Roll is :"+roll);
			
		}
		catch(InputMismatchException e)
		{
			e.printStackTrace();
		}		
		sc.close();
		System.out.println("Main ended");
	}
}
----------------------------------------------------------------------

public class TryDemo 
{
	public static void main(String[] args) 
	{
		try
		{
		   throw new Error();
		}
		catch (Exception e)
		{
			System.out.println("Inside Catch Block");
			e.printStackTrace();
		}
	}
}

Note : Here catch(Exception e) block is unable to handle because Error and Exception both are sub classes of Throwable, In the catch block
if we use Error OR Throwable then only catch block will handle.
-----------------------------------------------------------------------
Working with Infinity and Not a number(NaN) :
---------------------------------------------
Working with Infinity and Not a number(NaN) :
---------------------------------------------
10/0    -> Infinity (Java.lang.ArithmeticException)
10/0.0  -> Infinity  (POSITIVE_INFINITY)

0/0     -> Undefined (Java.lang.ArithmeticException)
0/0.0   -> Undefined  (NaN)

While dividing a number with Integral literal in both the cases i.e Infinity (10/0) and Undefined (0/0) we will get java.lang.ArithmeticException because java software people has not provided any final, static variable support to deal with Infinity and Undefined.

On the other hand while dividing a number with with floating point literal in the both cases i.e Infinity (10/0.0) and Undefined (0/0.0) we have final, static variable support so the program will not be terminated in the middle which are as follows

10/0.0 = POSITIVE_INFINITY
-10/0.0 = NEGATIVE_INFINITY
0/0.0 = NaN

java.lang.Float and java.lang.Double classes are provided the support for these final and static variable, the same OR same type of variables are not available in Integeral Literal classes.

package com.ravi.basic;

public class InfinityFloatingPoint 
{	
	public static void main(String[] args) 
	{
	   System.out.println("Main Started");
	   System.out.println(10/0.0); 
	   System.out.println(-10/0.0); 
	   System.out.println(0/0.0);
	   System.out.println(10/0); 
	   System.out.println("Main Ended");
	}

}
----------------------------------------------------------------------
Working with multiple try catch :
---------------------------------
According to our application requirement we can provide multiple try-catch in my application to work with multiple execptions.

Example :

try
{
}
catch(X e)
{
}

try
{
}
catch(X e)
{
}

try
{
}
catch(X e)
{
}

//Program :
-----------
package com.ravi.basic;
public class MultipleTryCatch 
{
	public static void main(String[] args) 
	{
	  System.out.println("Main method started!!!!");
	  
	  try
	  {
		  int arr[] = {10,20,30};
		  System.out.println(arr[3]);
	  }
	  catch(ArrayIndexOutOfBoundsException e)
	  {
		  System.err.println("Array index is out of limit!!!");
	  }
	  
	  try
	  {
		 String str = null;
		 System.out.println(str.length());
	  }
	  catch(NullPointerException e)
	  {
		  System.err.println("ref variable is pointing to null");
	  } 
	  
	  System.out.println("Main method ended!!!!");	
	}
}

Note : In the above program the drawback is, Client will get all the error messages at once which is not a recommended way.

In order to avoid this drawback we introduced multiple catch blocks with single try.
-----------------------------------------------------------------------
Multiple catch block with a single try block :
-----------------------------------------------
According to industry standard we should write try with multiple catch blocks so we can provide proper information for each and every exception to the end user.

While working with multiple catch block always the super class catch block must be last catch block.

From java 1.7v this multiple exceptions we can write in a single catch block by using | symbol.

If try block is having more than one exception then always try block will entertain only first exception because control will transfer to the nearest catch block.
-----------------------------------------------------------------------
package com.ravi.basic;
public class MultyCatch 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Started...");		
		try
		{
			int c = 10/0;			
			System.out.println("c value is :"+c);	
			
			int []x = {12,78,56};
			System.out.println(x[4]);		
		}
			
		catch(ArrayIndexOutOfBoundsException e1)
		{
			System.err.println("Array is out of limit...");
		}
		catch(ArithmeticException e1)
		{
			System.err.println("Divide By zero problem...");
		}
		catch(Exception e1)
		{
			System.out.println("General");
		}									
		System.out.println("Main Ended...");
	}
}
-----------------------------------------------------------------------
package com.ravi.basic;

public class MultyCatch1 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started!!!");
		try
		{
		   String str1 = "null";
		   System.out.println(str1.toUpperCase()); //NULL
		   
		   String str2 = "Ravi";
		   int x = Integer.parseInt(str2);
		   System.out.println("Number is :"+x);
		}
		catch(NumberFormatException  | NullPointerException  e)
		{
		  if(e instanceof NumberFormatException)
		  {
			  System.err.println("Number is not in a proper format");
		  }
		  else if(e instanceof NullPointerException)
		  {
			  System.err.println("ref variable is pointing to null");
		  }
		}

		System.out.println("Main method ended!!");
	}

}
----------------------------------------------------------------------
14-04-2025
----------
finally block : [Guarantted for execution regardless of Excption]
------------------------------------------------------------------
finally is a block which is meant for Resource handling purposes.

According to Software Engineering, the resources are memory creation, buffer creation, opening of a database, working with files, working with network resourses and so on hence these resourses must be closed properly.

Whenever the control will enter inside the try block always the finally block would be executed.

We should write all the closing statements inside the finally block because irrespective of exception finally block will be executed every time.

If we use the combination of try and finally then only the resources will be handled but not the execption, on the other hand if we use try-catch and finally then execption and resourses both will be handled.

finally block will not be executed in the following 2 cases :

 1) If we write System.exeit(0) and if this statement is executed in the try block.
 
 2) If we have infinite loop in the try block.

-----------------------------------------------------------------------
package com.ravi.basic;

public class FinallyBlock 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started");
		try
		{				
			System.out.println(10/0);
			System.exit(0);
		}		
		finally
		{	
			System.out.println("Finally Block");
		}
		
		System.out.println("Main method ended");
	}

}

Note :- In the above program finally block will be executed, even we have an exception in the try block but here only the resourses will be handled but not the exception.
-----------------------------------------------------------------------
package com.ravi.basic;

public class FinallyWithCatch 
{
	public static void main(String[] args) 
	{		
		try
		{			
		    int []x = new int[-2];	
		    x[0] = 12;
		    x[1] = 15;
		    System.out.println(x[0]+" : "+x[1]);	   
		   
		}
		catch(NegativeArraySizeException e)
		{		
			System.err.println("Array Size is in negative value...");			 
		}
		finally
		{
		   System.out.println("Resources will be handled here!!");		   
		}
		System.out.println("Main method ended!!!");
	}
}

In the above program exception and resourses both are handled because we have a combination of try-catch and finally.
-----------------------------------------------------------------------
Limitation of finally block :
------------------------------
We have following limitations with finally block 

1) A developer is responsible to write finally block, to close the 
   resourses manually.
2) User need to write finally block so It increases the length of the 
   code.
3) Any resourse which we want to close inside the finally block, must 
   be declared outside of try otherwise it will become block level 
   variable.

package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

public class LimitationOfFinally 
{

	public static void main(String[] args)
	{
		Scanner sc = null;
	    try
	    {
	    	 sc = new Scanner(System.in);
	    	System.out.println("Enter your Salary :");
	    	double salary = sc.nextDouble();
	    	System.out.println("Your Salary is :"+salary);
	    	
	    }
	    catch(InputMismatchException e)
	    {
	    	System.err.println("Input is not in a proper format");
	    }
	    finally
	    {
	    	System.out.println("Inside finally Block");
	    	sc.close();
	    }

	}

}

In order to resolve all the limitations of finally block, Java software people has introduced try with resourses from JDK 1.7V.
-----------------------------------------------------------------------
15-04-2025
-----------
try with Resourses (Automatic Closing Facility)
------------------------------------------------
To avoid all the limitation of finally block, Java software people introduced a separate concept i.e try with resources from java 7V onwards.

Case 1:
-------
try(resource1 ; resource2)  //Only the resources will be handled
{
}

Case 2 :
----------
//Resources and Exception both will be  handled
try(resource1 ; resource2) 
{                          
}
catch(Exception e)
{
}

Case 3 :
----------
try with resourses enhancement from java 9v

Resourse r1 = new Resourse();
MyResourse r2 = new MyResourse();

try(r1; r2)
{
}
catch(Exception e)
{
}

Note : The Resourse,MuResourse class must implements either from Closeable or AutoCloseable.

There is a predefined interface available in java.lang package called AutoCloseable from JDK 1.7 which contains predefined abstract method i.e close() which throws Exception.

There is another predefined interface available in java.io package called Closeable from JDK 1.5, this Closeable interface is the sub interface for AutoCloseable interface.

public interface java.lang.AutoCloseable
{
   public abstract void close() throws Exception;
}
public interface java.io.Closeable extends java.lang.AutoCloseable
{
   void close() throws IOException;
}

Whenever we pass any resourse class object as part of try with resources as a parameter then that class must implements either Closeable or AutoCloseable interface so, try with resourses will automatically call the respective class
close() method even an exception is encountered in the try block.

ResourceClass rc = new ResourceClass();
try(rc)  
{                                              
}                                               
catch(Exception e)                             
{                                          

}

This ResourceClass must implements either Closeable or AutoCloseable interface so, try block will automatically call the close() method as well as try block will get the guarantee of close() method support in the respective class.

-----------------------------------------------------------------------
The following program explains how try block will call the close method of DatabaseResourse and FileResourse class but both the class must implements either from java.io.Closeable OR java.lang.AutoCloseable.

package com.ravi.try_with_resourses;

public class DatabaseResourse implements AutoCloseable
{
	@Override
	public void close() throws Exception 
	{
		System.out.println("Database Resourse Closed Successfully!!!");		
	}

}

package com.ravi.try_with_resourses;

import java.io.Closeable;
import java.io.IOException;

public class FileResourse implements Closeable
{
	@Override
	public void close() throws IOException 
	{
		System.out.println("File Resourse closed Successfully!!!");
		
	}

}

package com.ravi.try_with_resourses;

public class TryWithResoursesDemo1 {

	public static void main(String[] args) throws Exception
	{
		DatabaseResourse dr = new DatabaseResourse();
		FileResourse fr = new FileResourse();
		
        try(dr; fr)
        {
        	System.out.println(10/0);
        }
        catch(ArithmeticException e)
        {
        	System.out.println(e);
        }
     

	}

}

Note : Whenever we use try with resourses then automatically one finally block will be inserted by the compiler to provide closing facility.
----------------------------------------------------------------------
try with resourses using Scanner class :
-----------------------------------------
package com.ravi.try_with_resourses;

import java.util.InputMismatchException;
import java.util.Scanner;

public class TryWithResoursesDemo2 
{
	public static void main(String[] args)
	{
		System.out.println("Main Method Started");
		Scanner sc = new Scanner(System.in);
		
		try(sc)
		{
			System.out.println("Enter your Age :");
            int age = sc.nextInt();
            System.out.println("Your Age is :"+age);            
		}
		catch(InputMismatchException e)
		{
			System.out.println("Input is not in a valid format");
		}
		System.out.println("Main Method Ended");
	}

}
-----------------------------------------------------------------------





































































































