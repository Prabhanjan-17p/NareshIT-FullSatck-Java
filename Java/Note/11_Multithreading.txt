21-04-2025
----------
Uniprocessing :- 
----------------
In uniprocessing, only one process can occupy the memory So the major drawbacks are 

1) Memory is westage
2) Resources are westage
3) Cpu is idle

To avoid the above said problem, multitasking is introduced.

In multitasking multiple tasks can concurrently work with CPU so, our task will be completed as soon as possible.

Multitasking is further divided into two categories.

a) Process based Multitasking [Diagram : 19th April]
b) Thread based Multitasking  [Diagram : 19th April]


Process based Multitasking :
----------------------------
If a CPU is switching from one subtask(Thread) of one process to another subtask of another process then it is called Process based Multitasking.

Thread based Multitasking :
---------------------------
If a CPU is switching from one subtask(Thread) to another subtask within the same process then it is called Thread based Multitasking.

What is a Thread ?
------------------
A thread is a light weight process. It is the basic unit of CPU.

A thread can concurrently run with another thread within the same process.

A thread is well known for Independent Exception in a separate Stack Memory.

The main purpose of the thread to provide fast execution so the particular task will be completed by multiple threads concurrently

In Java, Whenever we define main method then internally JVM create a thraed called main thread under main group

WAP that describes main is thread :
-----------------------------------
Whenever we define main method then JVM will create main thread internally under main group, the purpose of this main thread to execute the entire main method code.

In java there is a predefined class called Thread available in java.lang package, this class contains a predefined static factory method currentThread() which will provide currently executing Thread Object.

Thread t = Thread.currentThread(); //static Factory Method

Thread class has provided predefined non static method getName() to get the name of the Thread.
                 public final String getName();

Program :

package com.ravi.thread;

public class MainThread 
{
	public static void main(String[] args)
	{
		Thread t = Thread.currentThread();
                 System.out.println("Current Thread Name is :"+t.getName());    
              
                    //OR (Method Chaining)
        
        String name = Thread.currentThread().getName();
        System.out.println("Running Thread name is :"+name);
        
	}

}
-----------------------------------------------------------------------
How to create our own user defined Thread in java :
---------------------------------------------------
We can create user defined Thread by using the following two packages in java :

1) By using java.lang package (JDK 1.0)
2) By using java.util.concurrent sub package (JDK 1.5)

Creating Thread by java.lang Package :
--------------------------------------
We can create Thred by using one of the following two ways :

1) By extending java.lang.Thread class
2) By implementing java.lang.Runnable functional interface.
-----------------------------------------------------------------------
public synchronized void start() :
-----------------------------------
start() is a predefined non static method of Thread class which internally performs the following two tasks :

1) It will make a request to the O.S to assign a new thread for concurrent execution.

2) It will implicitly call run() method on the current object.

//Program
----------
package com.ravi.thread;

class UserThread extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child Thread is running"); 
	}
}

public class CustomThread 
{
	public static void main(String[] args)
	{
		System.out.println("Main Thread started!!!");		
		UserThread ut = new UserThread();
		ut.start();		
		System.out.println("Main Thread ended!!!");
	}

}

In the above program, we have two threads, main thread which is responsible to execute main method and Thread-0 thread which is responsible to execute run() method. [21 APRIL]

In entire Multithreading concept start() is the only method which is responsible to create a new thread.
-----------------------------------------------------------------------
22-04-2025
----------
public final boolean isAlive() :
---------------------------------
As we know when we call start() method then a new thread will be created in a separate Stack Memory.

Thread class has provided a predefined non static method called isAlive(), return type is boolean. This method is used to verify whether a thread has started or not, that thread is alive or not.

If we use isAlive() method before the start method then it will return false because Thread has not started, on the other hand if we use isAlive() method, after start() method then it will return true.

In java, We cannot re-start a thread, If we try to re-start then it will generate a runtime exception i.e java.lang.IllegalThreadStateException.

package com.ravi.basic;

class Foo extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child thread is running...");
		System.out.println("It is running with separate stack memory");		
	}	
}
public class IsAlive 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Thread started...");
		
		Foo f1 = new Foo();
		System.out.println("Is Thread alive : "+f1.isAlive());
		
		f1.start(); 
		
		System.out.println("Thread is alive or not : "+f1.isAlive());
		
		f1.start(); //java.lang.IllegalThreadStateException
		
		System.out.println("Main Thread ended...");	
	}
}
---------------------------------------------------------------------
package com.ravi.basic;

class Stuff extends Thread
{
	@Override
	public void run() 
	{		
		String name = Thread.currentThread().getName();		
		System.out.println("Child Thread is Running, name is :"+name);
	}	
}
public class ExceptionDemo 
{
	public static void main(String[] args)
	{		
		String name = Thread.currentThread().getName();		
	    System.out.println(name+" thread started");		
	
		Stuff s1 = new Stuff(); 
		Stuff s2 = new Stuff(); 		
				
		s1.start();
		s2.start();
		
		System.out.println(10/0);
		
		System.out.println("Main Thread Ended");
	}

}

Note :- Here main thread is interrupted due to AE but still child threads will be executed because child threads are executing with separate Stack.
-----------------------------------------------------------------------
package com.ravi.basic;

class Sample extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		
		for(int i=1; i<=10; i++)
		{
			System.out.println("i value is "+i+" by "+name+" thread");
		}
		
	}
}

public class ThreadLoop 
{
	public static void main(String[] args) 
	{
		Sample s1 = new Sample();
		s1.start();
		

        String name = Thread.currentThread().getName();
		
		for(int i=1; i<=10; i++)
		{
			System.out.println("i value is "+i+" by "+name+" thread");
		}
		
		int x=1;
		do
		{
			System.out.println("Multithreading");
			x++;
		}
		while(x<=10);	
		
	}

}

Note : Here processor is frequently switching from main thread to Thread-0 thread so output is un-predicatable.

We have something called Thread Schedular which is responsible to schedule the thread that means it is schedular who will decide which thread will get the processor time.
---------------------------------------------------------------------
How to set and get the name of the Thread :
-------------------------------------------
Whenever we create a userdefined Thread in java then by default JVM assigns the name of thread is Thread-0, Thread-1, Thread-2 and so on.

If a user wants to assign some user defined name of the Thread, then Thread class has provided a predefined method called setName(String name) to set the name of the Thread.

On the other hand we want to get the name of the Thread then Thread class has provided a predefined method called getName().

public final void setName(String name)  //setter

public final String getName()  //getter
----------------------------------------------------------------------
package com.ravi.basic;
class DoStuff extends Thread  
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println("Running Thread name is :"+name);
	}
}
public class ThreadName 
{
	public static void main(String[] args) 
	{
		DoStuff t1 = new DoStuff(); 
		DoStuff t2 = new DoStuff(); 
		
				
		t1.start();			
		t2.start();		
			
			
	System.out.println(Thread.currentThread().getName()+" thread is running.....");
	}
}

We are not providing the user-defined names so by default the name of thread would be Thread-0, Thread-1.
---------------------------------------------------------------
package com.ravi.basic;

class Demo extends Thread
{
	@Override
	public void run()
	{
		 String name = Thread.currentThread().getName();
		 System.out.println("Running Thread name is :"+name);
	}
}
public class ThreadName1 
{
	public static void main(String[] args) 
	{
	   Thread t = Thread.currentThread();
	   t.setName("Parent");
	   
	   Demo d1 = new Demo();
	   Demo d2 = new Demo();
	   
	   d1.setName("Child1");
	   d2.setName("Child2");
	   
	   d1.start();
	   d2.start();
	   
	   String name = Thread.currentThread().getName();
	   System.out.println(name + " Thread is running Here..");
	   
	   
	}
}

Note : Here we are providing the user-defined name i.e child1 and child2 for both the user-defined thread.
---------------------------------------------------------------
package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

class BatchAssignment extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		
		if(name !=null && name.equalsIgnoreCase("Placement"))
		{
			this.placementBatch();
		}
		else if(name !=null && name.equalsIgnoreCase("Regular"))
		{
			this.regularBatch();
		}
		else
		{
			throw new NullPointerException("Name can't be null");
		}
	}
	
	public void placementBatch()
	{
		System.out.println("I am a placement batch student.");
	}
	
	public void regularBatch()
	{
		System.out.println("I am a Regular batch student.");
	}
}


public class ThreadName2 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);	
		try(sc)
		{
			System.out.print("Enter your Batch Title [Placement/Regular] :");
			String title = sc.next();
			
			BatchAssignment b = new BatchAssignment();
			b.setName(title);
			
			b.start();
		}
		catch(InputMismatchException e)
		{
			System.out.println("Invalid Input");
		}
		
		
	}

}
=======================================================================
Thread.sleep(long millisecond) :
--------------------------------
sleep() is a predefined static method of Thread class which accepts long ms as a parameter.

The main purpose of sleep method to put a thread into temporarly waiting state OR sleeping state, The waiting period of the thread will depend upon the time specified by the user as a parameter of sleep() method.

Example :
Thread.sleep(1000);  //Thread will wait here for 1 second.

It is throwing a checked Exception i.e InterruptedException because there may be chance that this sleeping thread may be interrupted by a thread so provide either try-catch or declare the method as throws.

package com.ravi.basic;

class Sleep extends Thread
{
    @Override
    public void run() 
    {
    	for(int i=1; i<=10; i++)
    	{
    		System.out.println("i value is :"+i);
    		try
    		{
    			Thread.sleep(5000);
    		}
    		catch(InterruptedException e)
    		{
    			System.err.println("Catch Block");
                System.out.println(e);
    		}
    	}
    }
}
public class SleepDemo 
{
	public static void main(String[] args) 
	{
	   Sleep s1 = new Sleep();
	   s1.start(); 
	   s1.interrupt();
	     
	}
}
----------------------------------------------------------------------
package com.ravi.basic;

class MyTest extends Thread 
{	
		
	@Override
	public void run()  
	{	
		System.out.println("Child Thread id is :"+Thread.currentThread().getId());  //12 13
		
		for(int i=1; i<=5; i++)
		{
			System.out.println("i value is :"+i);  //11  22  33   44   55
			try
			{
				Thread.sleep(1000);
			}
			catch(InterruptedException e)
			{
				e.printStackTrace();
			}
		}
		
	}
}
public class SleepDemo1 
{
	public static void main(String[] args) 
	{		
		System.out.println("Main Thread id is :"+Thread.currentThread().getId());  //1
		
		MyTest m1 = new MyTest();		
		MyTest m2 = new MyTest();
		
		m1.start();
		m2.start();			
	}
}
-----------------------------------------------------------------------
23-04-2025
-----------
package com.ravi.basic;

class MyThread1 extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child Thread is running");
	}
}

public class SleepDemo2 {

	public static void main(String[] args) throws InterruptedException
	{
        System.out.println("Main thread is Started");	
        
        MyThread1 mt = new MyThread1();
        mt.start();
        
        //mt.sleep(2000);
        Thread.currentThread().sleep(2000);
        
        System.out.println("Main thread is Ended");	

	}

}

Note : Here main thrread will wait for 2 seconds.
-----------------------------------------------------------------------
Assignment :
------------
Thread.sleep(long mills, int nanos);
--------------------------------------------------------------
Old Thread life cycle (Before Java 1.5V) :[23rd JAN 25]
-----------------------------------------
As we know a thread is well known for Independent execution and it contains a life cycle which internally contains 5 states (Phases). 

During the life cycle of a thread, It can pass from thses 5 states. At a time a thread can reside to only one state of the given 5 states.

1) NEW State (Born state)

2) RUNNABLE state (Ready to Run state) [Thread Pool]

3) RUNNING state

4) WAITING / BLOCKED state

5) EXIT/Dead state

----------------------------------------------------------------------
New State :-
-------------
Whenever we create a thread instance(Thread Object) a thread comes to new state OR born state. New state does not mean that the Thread has started yet only the object or instance of Thread has been created.

Runnable state :-
-------------------
Whenever we call start() method on thread object, A thread moves to Runnable state i.e Ready to run state. Here Thread schedular is responsible to select/pick a particular Thread from Runnable state and sending that particular thread to Running state for execution.

Running state :-
-----------------
If a thread is in Running state that means the thread is executing its own run() method in a separate stack Memory.

From Running state a thread can move to waiting state either by an order of thread schedular OR user has written some method(wait(), join() or sleep()) to put the thread into temporarly waiting state.

From Running state the Thread may also move to Runnable state directly, if user has written Thread.yield() method explicitly.

Waiting state :-
------------------
A thread is in waiting state means it is waiting for it's time period to complete OR in some cases it is also waiting for lock (monitor) OR another thread to complete. Once the time period will be completed then it will re-enter inside the Runnable state to complete its remaining task.

Dead or Exit :
----------------
Once a thread has successfully completed its run method in the corresponding stack then the thread will move to dead state. Please remember once a thread is dead we can't restart a thread in java.
---------------------------------------------------------------------
IQ :- If we write Thread.sleep(1000) then exactly after 1 sec the Thread will re-start?

Ans :- No, We can't say that the Thread will directly move from waiting state to Running state. 

The Thread will definetly wait for 1 sec in the waiting state and then again it will re-enter into Runnable state which is control by Thread Schedular so we can't say that the Thread will re-start just after 1 sec.
---------------------------------------------------------------------
Anonymous inner class by using Thread class approach :
-------------------------------------------------------
Anonymous inner class by using Thread class with reference variable :
----------------------------------------------------------------------
package com.ravi.basic;

public class AnonymousInnerClassWithRef 
{
	public static void main(String[] args)
	{
		Thread thread = new Thread()
		{
			@Override
			public void run()
			{
				String name = Thread.currentThread().getName();
				System.out.println("Name of the Thread is :"+name);
			}
		};

		thread.start();
	}

}

Anonymous inner class by using Thread class without reference variable :
----------------------------------------------------------------------
package com.ravi.basic;

public class AnonymousInnerClassWithoutRef {

	public static void main(String[] args) 
	{
		new Thread()
		{
			@Override
			public void run()
			{
				String name = Thread.currentThread().getName();
				System.out.println("Name of the Thread is :"+name);
			}
		}.start();

	}
}
---------------------------------------------------------------------------
24-04-2025
-----------
join() method of Thread class :
-------------------------------
The main purpose of join() method to put the current thread into waiting state until the other thread finish its execution.

Here the currently executing thread stops its execution and the thread goes into the waiting state. The current thread remains in the wait state until the thread on which the join() method is invoked has achieved its dead state.

It also throws checked exception i.e InterruptedException so better to use try catch or declare the method as throws.

It is a non static method so we can call this method with the help of Thread object reference.

--------------------------------------------------------------------------
package com.ravi.basic;

class Join extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println(name+" Thread started");
		
		for(int i=1; i<=5; i++)
		{
			System.out.println("i value is :"+i+" by "+name+ " thread");
			try
			{
				Thread.sleep(1000);
			}
			catch(InterruptedException e)
			{
			  e.printStackTrace();	
			}			
		}
		System.out.println(name+" Thread ended");
	}	
}

public class JoinDemo 
{
	public static void main(String[] args) throws InterruptedException
	{
		System.out.println("Main Thread Started!!!!");
		
		Join j1 = new Join();
		Join j2 = new Join();
		Join j3 = new Join();
		
		j1.setName("J1");		
		j2.setName("J2");		
		j3.setName("J3");		
		
		j1.start();
		
		j1.join(); //Main thread  halt here
		
		j2.start();
		
		j3.start();	
		
		System.out.println("Main Thread Ended!!!!");
	}

}
--------------------------------------------------------------------------
package com.ravi.basic;

class Alpha extends Thread   
{
	@Override
	public void run()
	{
		Thread t = Thread.currentThread();
		String name = t.getName();	//Alpha_Thread is current thread		
		
		Beta b1 = new Beta();
		b1.setName("Beta_Thread");
        b1.start();  
        try 
        {
			b1.join(); //Alpha thread is waiting 4 Beta Thread to complete
		
			System.out.println("Alpha thread re-started");
		} 
        catch (InterruptedException e) 
        {			
			e.printStackTrace();
		}
		
		for(int i=1; i<=10; i++)
		{
			System.out.println(i+" by "+name);
		}
		
	}
}

public class JoinDemo2 
{
	public static void main(String[] args) 
	{
		Alpha a1 = new Alpha();
		a1.setName("Alpha_Thread");
		a1.start();
	}
}

class Beta extends Thread
{
	@Override
	public void run()
	{
		Thread t = Thread.currentThread();
		String name = t.getName();	//Beta_Thread
		
		for(int i=1; i<=20; i++)
		{
			System.out.println(i+" by "+name);
			try
			{
				Thread.sleep(500);
			}
			catch(InterruptedException e) {
				
			}
		}
		System.out.println("Beta Thread Ended");
	}
}
--------------------------------------------------------------------------
package com.ravi.basic;

public class JoinDemo1 
{
	public static void main(String[] args) throws InterruptedException 
	{
       System.out.println("Main Thread started");
       
       Thread t = Thread.currentThread();
       
       for(int i=1; i<=10; i++)
       {
    	   System.out.println(i+" by "+t.getName());
       }
      
       t.join();  //Main thread is waiting for main thread to complete (Deadlock)
       
       System.out.println("Main Thread ended");
      
	}
}

Note : It is a deadlock state because main thread is waiting for main thread to complete.
----------------------------------------------------------------------
Assigning the target for the thread by using Runnable interface :
-----------------------------------------------------------------
package com.nit.testing;

class UserThread implements Runnable
{   
	@Override
    public void run()
    {
         System.out.println("User Thread is running");
    }
}
class RunnableDemo
{
    public static void main(String [] args)
    {
    	System.out.println("Main Thread started");
    	
    	UserThread ut = new UserThread();
    	
    	Thread t1 = new Thread(ut);
    	t1.start(); 	
    	
    }
}

Note : Here Overriding run() method is compulsory and to create a new thread we need to call Thread class start() method.
----------------------------------------------------------------------
25-04-2025
-----------
Assigning target to different threads :
----------------------------------------
package com.ravi.testing_demo;

class Tatkal implements Runnable 
{	
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println(name+" is booking the tatkal Ticket!!!");
			
	}	
}

class PremimumTatkal implements Runnable
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println(name+" is booking the premimum tatkal Ticket!!!");	
	}	
}

class GeneralTicket implements Runnable
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println(name+" is booking the General Ticket!!!");	
	}	
}


public class AssigningTarget 
{
	public static void main(String[] args) throws InterruptedException 
	{
		Thread alen = new Thread(new Tatkal(),"Mr. Alen");		
		
		Thread scott = new Thread(new PremimumTatkal(),"Mr. Scott");		
		
		Thread smith = new Thread(new GeneralTicket(),"Mr. Smith");		

		scott.start();
		
		scott.join();
		
		alen.start();
		
		alen.join();
			
		smith.start();
	}

}
--------------------------------------------------------------------
Runnable interface by using different Cases :
----------------------------------------------
Case 1 :
--------
Runnable interface by using Anonymous inner class :
----------------------------------------------------
package com.ravi.cases;

public class AnonymousApproach {

	public static void main(String[] args) 
	{
		Runnable r1 = new Runnable() 
		{			
			@Override
			public void run() 
			{
				String name = Thread.currentThread().getName();
				System.out.println("Thread name is :"+name);
				
			}
		};
		
	    Thread t1 = new Thread(r1,"Child1");
	    t1.start();
		

	}

}
-------------------------------------------------------------------
Case 2 :
---------
Anonymous inner class by using Thred class constructor :
--------------------------------------------------------

package com.ravi.cases;

public class AnontmousWithThreadConstructor {

	public static void main(String[] args) 
	{
		Thread t1 = new Thread(new Runnable()    //Anonymous inner class
		{
			@Override
			public void run() 
			{
				String name = Thread.currentThread().getName();
				System.out.println("Thread name is :"+name);				
			}				
		});
		
		t1.start();

	}

}
--------------------------------------------------------------------
Case 3 : 
--------
Runnable by using Lambda :
--------------------------
package com.ravi.cases;

public class RunnableByLambda {

	public static void main(String[] args) 
	{
		Runnable r1 =   () -> 
		{
			String name = Thread.currentThread().getName();
			System.out.println("Thread name is :"+name);
		};
		
		Thread t1 = new Thread(r1);
		t1.start();

	}

}
-------------------------------------------------------------------
Case 4 :
---------
Lambda by using Thred class constructor with/withot reference :
---------------------------------------------------------------

package com.ravi.cases;

public class LAmbdaByRef {

	public static void main(String[] args) 
	{
	        //With Ref
		Thread t1 = new Thread(()-> System.out.println(Thread.currentThread().getName()),"Child1");
		t1.start();
		
		//OR
		//Without Ref
		new Thread(()-> System.out.println(Thread.currentThread().getName()),"Child2").start();

	}

}
--------------------------------------------------------------------
Thread class Constructor :
---------------------------
Thread is a predefined class available in java.lang package. It contains 10 constructors. We we have the list of constructors which we are using commonly.

1) Thread t1 = new Thread();
2) Thread t2 = new Thread(String name);
3) Thread t3 = new Thread(Runnable target);
4) Thread t4 = new Thread(Runnable target, String name);
5) Thread t5 = new Thread(ThreadGroup tg, String name);  
6) Thread t6 = new Thread(ThreadGroup tg, Runnable target);  
7) Thread t7 = new Thread(ThreadGroup tg, Runnable target, String name);
---------------------------------------------------------------------
26-04-2025
----------
Drawback of Multithreading :
----------------------------
Multithreading is very good to complete our task as soon as possible but in some situation, It provides some wrong data or wrong result.

In Data Race or Race condition, all the threads try to access the resource at the same time so the result may be corrupted.

In multithreading if we want to perform read operation and data is not updatable data then multithreading is good but if the data is updatable data (modifiable data) then multithreading may produce some wrong result or wrong data which is known as Data Race OR race condition as shown in the diagram.(25-APR)
--------------------------------------------------------------------
package com.ravi.basic;

class Customer implements Runnable
{
	private int availableSeat = 1;
	private int wantedSeat; //1
	
	public Customer(int wantedSeat)
	{
		super();
		this.wantedSeat = wantedSeat;
	}
	
	@Override
	public void run() 
	{
	  	String name = null;
	  	
	  	if(availableSeat >= wantedSeat)
	  	{
	  		name = Thread.currentThread().getName();
	  		System.out.println(wantedSeat+" seat is reserved for "+name);
	  		availableSeat = availableSeat - wantedSeat;
	  	}
	  	else
	  	{
	  		name = Thread.currentThread().getName();
	  		System.err.println("Sorry!!!"+name+" seat is not available");
	  	}			
	}	
}
public class RailwayReservation 
{
	public static void main(String[] args) throws InterruptedException 
	{
		Customer c1 = new Customer(1);
		
		Thread t1 = new Thread(c1,"Scott");
		Thread t2 = new Thread(c1,"Smith");
		
		t1.start();  
		t2.start();
		

	}

}

//Bank Account money withdraw by using Lambda :
-----------------------------------------------
package com.ravi.testing_demo;

class Customer
{
	private double balance = 20000;
	private double withAmount;
	
	public Customer(double withAmount) 
	{
		super();
		this.withAmount = withAmount;
	}
	
	public void withdraw()
	{
		String name = null;
		
		if(this.withAmount<=this.balance)
		{
			name = Thread.currentThread().getName();
			System.out.println(this.withAmount+" amount is withdraw by :"+name);
			this.balance = this.balance - this.withAmount;
			System.out.println("Current Balance is :"+this.balance);
		}
		else
		{			
			name = Thread.currentThread().getName();
			System.err.println("Sorry!!"+name+ " you have insufficient Balance");
		}
		
	}	
}

public class BankingApplication {

	public static void main(String[] args) 
	{
		Customer cust = new Customer(20000);
		
		Runnable r1 = () -> cust.withdraw();
		
		
		Thread t1 = new Thread(r1, "Scott");
		Thread t2 = new Thread(r1, "Smith");
		
		t1.start();  t2.start();

	}

}
---------------------------------------------------------------------
***Synchronization :
-------------------
In order to solve the problem of multithreading java software people has introduced synchronization concept.

In order to acheive sycnhronization in java we have a keyword called "synchronized".

It is a technique through which we can control multiple threads but accepting only one thread at all the time.

Synchronization allows only one thread to enter inside the synchronized area for a single object.

Synchronization can be divided into two categories :-

1) Method level synchronization

2) Block level synchronization

1) Method level synchronization :-
-----------------------------------
In method level synchronization, the entire method gets synchronized so all the thread will wait at method level and only one thread will enter inside the synchronized area as shown in the diagram.(26-04-25) 

2) Block level synchronization
-------------------------------
In block level synchronization the entire method does not get synchronized, only the part of the method gets synchronized so all the thread will enter inside the method but only one thread will enter inside the synchronized block as shown in the diagram (26-04-25) 

Note :- In between method level synchronization and block level synchronization, block level synchronization is more preferable because all the threads can enter inside the method so only the PART OF THE METHOD GETS synchronized so only one thread will enter inside the synchronized block.

Note :  Synchronized area is a restricated area, with permission only a thread can enter inside synchronized area.
---------------------------------------------------------------------
How synchronization mechanism controls multiple thread OR Among 'n' number of threads which thread is allowed to enter inside synchronized area ?
--------------------------------------------------------------------------------------------------------------------------------------------------
Every Object has a lock(monitor) in java environment and this lock can be given to only one Thread at a time.

Actually this lock is available with each individual object provided by Object class. 

*The thread who acquires the lock from the object will enter inside the synchronized area, it will complete its task without any disturbance because at a time there will be only one thread inside the synchronized area(for single Object). *This is known as Thread-safety in java.

The thread which is inside the synchronized area, after completion of its task while going back will release the lock so the other threads (which are waiting outside for the lock) will get a chance to enter inside the synchronized area by again taking the lock from the object and submitting it to the synchronization mechanism.
This is how synchronization mechanism controls multiple Threads.

Note :- Synchronization logic can be done by senior programmers in the real time industry because due to poor synchronization there may be chance of getting deadlock.

---------------------------------------------------------------------
package com.ravi.testing_demo;

class Table
{
   public synchronized void printTable(int num) 
   {
      for(int i=1; i<=10; i++)
      {
         System.out.println(num*i);
         try
         {
        	 Thread.sleep(1000);
         }
         catch(InterruptedException e)
         {
        	 e.printStackTrace();
         }
      }
      System.out.println("..............");
   }
}
public class MethodLevelSynchronization {

	public static void main(String[] args)  
	{
       Table obj = new Table();		//lock is created
       
       Thread t1 = new Thread()
       {
    	   @Override
    	   public void run()
    	   {
    		   obj.printTable(5);
    	   }
       };
       
       Thread t2 = new Thread()
       {
    	   @Override
    	   public void run()
    	   {
    		   obj.printTable(2);
    	   }
       };

       t1.start();     
       
       t2.start();
       
       
	}

}
---------------------------------------------------------------------
//Program on Block Level Synchronization :
-------------------------------------------
package com.ravi.advanced;

//Block level synchronization

class ThreadName
{
	public void printThreadName()  
	{		  		
	  String name = Thread.currentThread().getName();
	  System.out.println("Thread inside the method is :"+name);
			
		   synchronized(this)  //synchronized Block
		   {  			   
			for(int i=1; i<=9; i++)   
			{
				System.out.println("i value is :"+i+" by :"+name);
			}
			System.out.println(".............................");
		   }		
	}
}
public class BlockSynchronization 
{
	public static void main(String[] args)
	{
		ThreadName obj1 = new ThreadName(); //lock is created	
		
		Runnable r1 = () -> obj1.printThreadName();
		
		Thread t1 = new Thread(r1,"Child1"); 
		Thread t2 = new Thread(r1,"Child2"); 
		t1.start(); t2.start();				
	}
}
--------------------------------------------------------------------
28-04-2025
-----------
Drawback of Object level synchronization :
-------------------------------------------
From the given diagram it is clear that there is no interference between t1 and t2 thread because they are passing throgh Object1 where as on the other hand there is no interferenec even in between t3 and t4 threads because they are also passing through Object2 (another object).

But there may be chance that with t1 Thread (object1), t3 or t4 thread can enter inside the synchronized area at the same time, simillarly it is also possible that with t2 thread, t3 or t4 thread can enter inside the synchronized area so the conclusion is, synchronization mechanism does not work with multiple Objects.(Diagram 28-APR-25)
---------------------------------------------------------------------
package com.ravi.advanced;

class PrintTable
{	    
	    public synchronized void printTable(int n)
	    {
	       for(int i=1; i<=10; i++)
	       {
	    	   System.out.println(n+" X "+i+" = "+(n*i));
	    	   try
	    	   {
	    		   Thread.sleep(500);
	    	   }
	    	   catch(InterruptedException e)
	    	   {	    		   
	    	   }
	       }
	       System.out.println(".......................");
	    }	
}

public class ProblemWithObjectLevelSynchronization
{
	public static void main(String[] args) 
	{	
		PrintTable pt1 = new PrintTable(); //lock1
		PrintTable pt2 = new PrintTable(); //lock2
		
		Thread t1 = new Thread()  //Anonymous inner class concept
				{
			       @Override
			       public void run()
			       {
			    	  pt1.printTable(5); //lock1
			       }			   
				};
		       	        
		        Thread t2 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt1.printTable(10); //lock1
			       }			   
				};
		                
		        Thread t3 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt2.printTable(15); //lock2
			       }			   
				};
		               
		        Thread t4 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt2.printTable(20); //lock2
			       }			   
				};
				 t1.start();	t2.start();	 t3.start();  t4.start(); 
	}
}


Note : From the above program it is clear that synchronization logic will not work with multiple objects.
       
---------------------------------------------------------------------
In order to avoid the drawback of Object level synchronization, Java software people introduced static synchronization.

** Static Synchronization :
---------------------------
If we make our synchronized method as static then it is called static synchronization.

For static synchronization "Object is not required". Static method we can call with the help of class name.

In static synchronization, the thread will take the lock from the class but not from the Object. [Every class has a lock]

Unlike objects, We can't create multiple classes in the same package. 
       
package com.ravi.advanced;
class MyTable     
{
	 public static synchronized void printTable(int n)  //static synchronization
	    {
		 for(int i=1; i<=10; i++)
	       {
	    	   try
	    	   {
	    		   Thread.sleep(500);
	    	   }
	    	   catch(InterruptedException e)
	    	   {
	    		  System.err.println("Thread is Interrupted...");
	    	   }
	    	   System.out.println(n+" X "+i+" = "+(n*i));
	       }
	       System.out.println("------------------------");
	    }
}
public class StaticSynchronization 
{
	public static void main(String[] args)
	{
			        Thread t1 = new Thread()
					{
				      @Override
				      public void run()
				      {
				    	 MyTable.printTable(5); 
				      }
					};		
					
					Thread t2 = new Thread()
					{
				      @Override
				      public void run()
				      {
				    	  MyTable.printTable(10);
				      }
					};										

					Runnable r3 = ()-> MyTable.printTable(15);
					Thread t3 = new Thread(r3);
					
					t1.start();
					t2.start();	
					t3.start();
					
		}
}
------------------------------------------------------------------
How to work with synchronized block, If we want to take the lock from the class.

synchronized(MyClass.class) //Taking the lock from the class
{

}
--------------------------------------------------------------------
Thread Priority :
-----------------
It is possible in java to assign priority to a Thread. Thread class has provided two predefined methods setPriority(int newPriority) and getPriority() to set and get the priority of the thread respectively.

public final void setPriority(int newPriority)
{
}
public final int getPriority()
{
   return this.priority;
}

In java we can set the priority of the Thread in numbers from 1- 10 only where 1 is the minimum priority and 10 is the maximum priority.

Whenever we create a thread in java by default its priority would be 5 that is normal priority.

The user-defined thread created as a part of main thread will acquire the same priority of main Thread.

Thread class has also provided 3 final static variables which are as follows :-

Thread.MIN_PRIORITY  :- 01

Thread.NORM_PRIORITY : 05

Thread.MAX_PRIORITY  :- 10

Note :- We can't set the priority of the Thread beyond the limit(1-10) so if we set the priority beyond the limit (1 to 10) then it will generate an exception java.lang.IllegalArgumentException.
---------------------------------------------------------------------
package com.ravi.priority;

public class PriorityDemo1 
{
	public static void main(String[] args) 
	{
		int priority = Thread.currentThread().getPriority();
		System.out.println("Main thread priority is :"+priority);
		
		Thread t1 = new Thread();
		System.out.println("Child Thread priority is :"+t1.getPriority());
	}

}
---------------------------------------------------------------------
package com.ravi.priority;

class MyThread implements Runnable
{	
	public void run()
	{
	   int priority = Thread.currentThread().getPriority();
	   System.out.println("Child Thread priority is :"+priority);
	}	
}

public class PriorityDemo2 
{
	public static void main(String[] args)
	{
		Thread t = Thread.currentThread();
		t.setPriority(Thread.MAX_PRIORITY);
		//t.setPriority(11);  //java.lang.IllegalArgumentException
		
		System.out.println("Main Thread priority is :"+t.getPriority());
		
		Thread t1 = new Thread(new MyThread());
		t1.start();
	}

}
--------------------------------------------------------------------
package com.ravi.priority;

class UserThread implements Runnable
{
	@Override
	public void run() 
	{
		int priority = Thread.currentThread().getPriority();
		String name = Thread.currentThread().getName();
		
		int count = 0;
		
		for(int i=1; i<1000000; i++)
		{
			count++;
		}
		
		System.out.println("The thread name is :"+name);
		System.out.println("The thread priority is :"+priority);
		
	}
	
}
public class PriorityDemo3 
{
	public static void main(String[] args) 
	{
		UserThread ut = new UserThread();
		
		Thread t1 = new Thread(ut, "Last_Thread");
		Thread t2 = new Thread(ut, "First_Thread");

		t1.setPriority(Thread.MIN_PRIORITY); //Lowest Priority
		t2.setPriority(Thread.MAX_PRIORITY); //Highest Priority
		
		t1.start(); t2.start();
		
	}

}
--------------------------------------------------------------------
package com.ravi.priority;

class UserThread implements Runnable
{
	@Override
	public void run() 
	{
		int priority = Thread.currentThread().getPriority();
		String name = Thread.currentThread().getName();
		
		int count = 0;
		
		for(int i=1; i<1000000; i++)
		{
			count++;
		}
		
		System.out.println("The thread name is :"+name);
		System.out.println("The thread priority is :"+priority);
		
	}
	
}
public class PriorityDemo3 
{
	public static void main(String[] args) 
	{
		UserThread ut = new UserThread();
		
		Thread t1 = new Thread(ut, "Last_Thread");
		Thread t2 = new Thread(ut, "First_Thread");

		t1.setPriority(Thread.MIN_PRIORITY); //Lowest Priority
		t2.setPriority(Thread.MAX_PRIORITY); //Highest Priority
		
		t1.start(); t2.start();
		
	}

}

Most of time the thread having highest priority will complete its task but we can't say that it will always complete its task first that means Thread schedular dominates Priority of the Thread.
---------------------------------------------------------------------
29-04-2025
------------
Thread.yield() : [To Prevent a thread from over utilization of CPU]
----------------
It is a static method of Thread class.

The currently executing thread will send a notification to thread schedular to stop the currently executing Thread (In Running state) and provide a chance to Threads which are in Runnable state to enter inside the running state having same priority or higher priority than currently executing Thread. 

Here The running Thread will directly move from Running state to Runnable state.

The Thread schedular may accept OR ignore this notification message given by currently executing Thread.

Here there is no guarantee that  after using yield() method the running Thread will move to Runnable state and the thread which is running thread will move to Runnable state. 

If the thread which is in runnable state is having low priority than the current executing thread in Running state, will continue its execution.

*It is mainly used to avoid the over-utilisation a CPU by the current Thread so all the threads will get equal chance of CPU for execution.

package com.ravi.thread;

class Test implements Runnable
{
	@Override
	public void run() 
	{
		String name = Thread.currentThread().getName();
		
		for(int i=1; i<=10; i++)
		{
			System.out.println(i+" by "+name+" thread");
		
			if(name.equals("child1"))
			{
				Thread.yield();  //Give the chance to Child2
			}		
		}		
	}	
}
public class YieldDemo 
{
	public static void main(String[] args)
	{
		Test test = new Test();
		
		Thread t1 = new Thread(test, "child1");
		Thread t2 = new Thread(test, "child2");
		
		t1.start();
		t2.start();
	}

}
--------------------------------------------------------------------
New Thread life Cycle :
-------------------------------------
A thread is well known for independent execution, During the life cycle of a thread it passes through different states

Java has provided a new Thread life cycle from JDK 1.5V with the support of enum.

We have a predefined enum called State which is available inside Thread class and it represents life cycle constants which are as follows :

1) NEW (Born State)
2) RUNNABLE (Ready to Run)
3) BLOCKED (Waiting for Object lock to enter OR reenter in syn area)
4) WAITING (Witing for another thread to complete, join() wait())
5) TIMED_WAITING (Waiting for time period to complete, sleep(1000))
6) TERMINATED (Dead)

NEW :
-----
Whenever we create a thread instance(Thread Object) a thread comes to new state OR born state. New state does not mean that the Thread has started yet only the object or instance of Thread has been created.

RUNNABLE :
-----------
Whenever we call start() method on thread object, A thread moves to Runnable state i.e Ready to run state. Here the thread is considered "alive," but it doesnt immediately start execution unless the CPU scheduler assigns it time.

BLOCKED :
---------
If a thread is waiting for object lock OR monitor to enter inside synchronized area OR re-enter inside synchronized area then it is in blocked state.

WAITING :
---------
A thread in the waiting state is waiting for another thread to perform a particular action but WITHOUT ANY TIMEOUT period. A thread that has called wait() method on an object is waiting for another thread to call notify() or notifyAll() on the same object OR A thread that has called join() method is waiting for a specified thread to terminate.

TIMED_WAITING :
---------------
A thread in the timed_waiting state, if we call any method which put the thread into temporarly timed_waiting state but WITH POSITIVE TIMEOUT period like sleep(lons ms), join(long ms), wait(long ms) then the Thread is considered as Timed_Waiting state.

TERMINATED :
-------------
The thread has successuflly completed it's execution in the separate stack memory that means run() method is successfully completed.

========================================================================
*** Inter Thread Communication (ITC)
-------------------------------------
It is a mechanism to communicate or co-ordinate between two synchronized threads within the context to achieve a particular task.

In ITC we put a thread into wait mode by using wait() method and other thread will complete its corresponding task, after completion of the task it will call notify() method so the waiting thread will get a notification to complete its remaining task.

ITC can be implemented by the following method of Object class.

1) public  final void wait() throws InterruptedException

2) public native final void notify()

3) public native final void notifyAll()


public  final void wait() throws InterruptedException :-
-------------------------------------------------------------
It is a predefined non static method of Object class. We can use this method from synchronized area only otherwise we will get java.lang.IllegalMonitorStateException.

It will put a thread into temporarly waiting state and it will release the Object lock, It will remain in the waiting state till another thread provides a notification message on the same object, After getting the notification the waiting thread will move to BLOCKED state and now it is waiting for Object lock to re-enter inside synchronized area.

It throws a checked Exception i.e InterruptedException.

public native final void notify() :-
-------------------------------------
It will wake up the single thread that is waiting on the same object.It will not release the lock , once synchronized area is completed then only lock will be released.

Once a waiting thread will get the notification from the another thraed using notify()/notifyAll() method then the waiting thread will move to Blocked state and once it will get the lock then it will come to Runnable state, now It depends upon the Thread scheduler to schedule this thread for execution.

public native final void notifyAll() :-
----------------------------------------
It will wake up all the threads which are waiting on the same object.It will not release the lock , once synchronized area is completed then only lock will be released.

IQ :
--
Why wait(), notify() and notifyAll() methods are defined in Object class but not in Thread class.

wait(), notify() and notifyAll() methods are defined in Object class but not in Thread class because in order to use these methods we need synchronized area otherwise it will generate a runtime execption i.e java.lang.IllegalMonitorStateException.

In order to call these methods lock is required (due to synchronized area) and lock is available with Object class hence these methods are defined in Object class but not in Thread class.

IQ :
-----
**** Difference between sleep() and wait()
---------------------------------------------

Differences are available in paint Diagram [30-APR]
------------------------------------------------------------------------
package com.ravi.itc;

public class ITCDemo1 
{
  public static void main(String[] args) throws InterruptedException 
  {
	 Object obj = new Object();
	 obj.wait();
	 
	
  }	
	
}


Note : From this program it is clear if we don't use wait() method from the synchronized area then we will get java.lang.IllegalMonitoStateException.

//Program that describes if we don't use proper communication between two thraeds then output is un-predictable.

package com.ravi.itc;

class Test extends Thread
{
	private int data = 0;
	
	@Override
	public void run()
	{
		for(int i=1; i<=10; i++)
		{
			this.data = this.data + i;   //0   1   3    6   10   15  21
			
			   try
		       {
		    	   Thread.sleep(100);
		       }
		       catch(InterruptedException e)
		       {
		    	   e.printStackTrace();
		       }
		}
	}
	
	public int getData()
	{
		return this.data;
	}	
}

public class ITCDemo2 
{
	public static void main(String[] args) throws InterruptedException 
	{
       System.out.println("Main Thread Started...");
       
       Test t1 = new Test();
       t1.start();
      
       
       try
       {
    	   Thread.sleep(100);
       }
       catch(InterruptedException e)
       {
    	   e.printStackTrace();
       }
          
       
      System.out.println(t1.getData());
      
	}
}
------------------------------------------------------------------------
How to get proper output by usng ITC :
---------------------------------------
package com.ravi.itc;

class Demo extends Thread
{
	private int data = 0;
	
	@Override
	public void run()
	{
		synchronized(this)
		{
			System.out.println("Child thread got the lock and starts execution");
			for(int i=1; i<=10; i++)
			{
			    this.data = this.data + i;	
			}	
			System.out.println("Child thread is sending notification");
			notify();		
			
		}//Lock will be free here
	}
	
	public int getData()
	{
		return this.data;
	}
	
	
}

public class ITCDemo3 
{
	public static void main(String[] args) throws InterruptedException 
	{		
		System.out.println("Main Thread Started...");
		
		Demo d1 = new Demo(); //lock
		d1.start();
		
			
		synchronized(d1)
		{			
			System.out.println("Main thread is going to wait after releasing the Lock");
			d1.wait(); //lock released + Waiting state
			System.out.println("Main thread got notification and lock");
			System.out.println(d1.getData());
		}
		
	}

}
------------------------------------------------------------------------
package com.ravi.itc;

class Customer
{
	private double balance;

	public Customer(double balance)
	{
		super();
		this.balance = balance;
	}
	
	
	public synchronized void withdraw(double amount)
	{
		System.out.println("Going to Withdraw");
		if(amount > this.balance)
		{
			System.out.println("Less amount, Waiting for deposit");
			try
			{
				wait();
				System.out.println("Got the notification");
			}
			catch(InterruptedException e)
			{
				System.err.println(e);
			}
		}
		this.balance = this.balance - amount;
		System.out.println("Balance after withdraw is :"+this.balance);
	}
	
	
	public synchronized void deposit(double amount)
	{
		System.out.println("Going to deposit");
		this.balance = this.balance + amount;
		System.out.println("Balance after deposit is :"+this.balance);
		notify();
	}
}

public class ITCDemo4 
{	
	public static void main(String[] args)
	{
		Customer cust = new Customer(10000);  //lock
		
	    Thread son = new Thread()
	    {
	       @Override
	       public void run()
	       {
	    	   cust.withdraw(15000);
	       }
	    };
	    
	    son.start();
	    
	    Thread dad = new Thread()
	    {
	       @Override
	       public void run()
	       {
	    	   cust.deposit(10000);
	       }
	    };
		
	    
	    dad.start();
 	}

}
---------------------------------------------------------------------
01-05-2025
----------
package com.ravi.itc;

class TicketSystem  
{
    private int availableTickets = 5;   //availableTickets = 5
    
    public synchronized void bookTicket(int numberOfTickets) //4
    {
        while (availableTickets < numberOfTickets) 
        {
           System.out.println("Not enough tickets available, Waiting for cancellation...");
            try 
            {
                wait(); 
            }
            catch (InterruptedException e) 
            {
                e.printStackTrace();
            }
        }
        availableTickets = availableTickets - numberOfTickets;  
        
        System.out.println("Booked " + numberOfTickets + " ticket(s). Remaining tickets: " + availableTickets);
        notify();               
    }

    
  public synchronized void cancelTicket(int numberOfTickets) //numberOfTickets = 2
    {
        availableTickets = availableTickets + numberOfTickets;
        System.out.println("Canceled " + numberOfTickets + " ticket(s). Available tickets: " + availableTickets);
        notify(); 
    }
}
public class ITCDemo5 
{
    public static void main(String[] args) 
    {
        TicketSystem ticketSystem = new TicketSystem(); //lock is created//"

        Thread bookingThread = new Thread()
        {
        	@Override
            public void run() 
        	{
                int[] ticketsToBook = {2, 4, 4};  
                
                for (int ticket : ticketsToBook) //ticket = 4 (3rd Iteration)
                {
                    ticketSystem.bookTicket(ticket);
                    try 
                    {
                        Thread.sleep(1000); // give some time b/w booking
                    } 
                    catch (InterruptedException e)
                    {
                        e.printStackTrace();
                    }
                }
        	 }        	
        };
        bookingThread.start();
        
        
        Thread cancellationThread = new Thread()
       	{
        	@Override
            public void run() 
        	{
                int[] ticketsToCancel = {1, 3, 2};
                
                for (int ticket : ticketsToCancel) //ticket = 2 (3rd Iteration)
                {
                    ticketSystem.cancelTicket(ticket);
                    try 
                    {
                        Thread.sleep(1500);  // give some time b/w cancellation
                    } 
                    catch (InterruptedException e) 
                    {
                        e.printStackTrace();
                    }
                }
            }
        };
        cancellationThread.start();
            
        
        
    }
}


Note : It is poosible while working with ITC that a synchronized method can use wait() and notify() both are methods.
---------------------------------------------------------------------
program on notifyAll() :
-------------------------
package com.ravi.itc;

class Resource 
{
    private boolean flag = false;

    public synchronized void waitMethod() 
	{
		System.out.println("Wait");  
		
       	while (!flag)   //Due to ! It is finiite loop
		{
          try 
		  {
             System.out.println(Thread.currentThread().getName() + " is waiting...");
             System.out.println(Thread.currentThread().getName()+" is Waiting for Notification");
             wait(); //child1  child2  child3
          } 
		  catch (InterruptedException e) 
		  {
                e.printStackTrace();
          }
        }//while loop
       	
        System.out.println(Thread.currentThread().getName() + " thread completed!!");
    }

    
    public synchronized void setMethod() 
	{
		System.out.println("notifyAll");
		this.flag = true;
        System.out.println(Thread.currentThread().getName() + " has make flag value as a true");
        notifyAll(); // Notify all waiting threads that the signal is set
    }
}

public class ITCDemo6
{
    public static void main(String[] args) 
		{     	
    	
        Resource r1 = new Resource(); //lock is created

        Thread t1 = new Thread(() -> r1.waitMethod(), "Child1");
		Thread t2 = new Thread(() -> r1.waitMethod(), "Child2");
		Thread t3 = new Thread(() -> r1.waitMethod(), "Child3");

		t1.start();
        t2.start();
        t3.start();
       
		
		Thread setter = new Thread(() -> r1.setMethod(), "Setter_Thread");
      
		   try 
			{
	            Thread.sleep(2000);
	        } 
			catch (InterruptedException e) 
			{
	            e.printStackTrace();
	        }
		
	       setter.start();
    }
}
=====================================================================
02-05-2025
-----------
ThreadGroup :
-------------
It is a predefined class available in java.lang Package.

By using ThreadGroup class we can put 'n' number of threads into a single group to perform some common/different operation.

By using ThreadGroup class constructor, we can assign the name of group under which all the thread will be executed.

ThreadGroup tg = new ThreadGroup(String groupName);

ThreadGroup class has provided the following methods :

public String getName() : To get the name of the Group

pubic int activeCount() : How many threads are alive and running under that particular group.

Thread class has provided constructor to put the thread into particular group.

Thread t1 = new Thread(ThreadGroup tg, Runnable target, String name);

By using ThreadGroup class, multiple threads will be executed under single group.

WAP to assign different threads which are runing into a particular group.

package com.ravi.thread_group;

class Target implements Runnable
{
	@Override
	public void run() 
	{
		String name = Thread.currentThread().getName();	
		for(int i=1; i<=30; i++)
		{			
		   System.out.println(name+" is running for "+i+" time");
		}
	}	
}

public class ThreadGroupDemo1 
{
	public static void main(String[] args) 
	{
	   ThreadGroup tg = new ThreadGroup("Batch_42_43"); 	
	   
	   Thread t1 = new Thread(tg, new Target(), "Child1");
	   Thread t2 = new Thread(tg, new Target(), "Child2");
	   Thread t3 = new Thread(tg, new Target(), "Child3");
	   Thread t4 = new Thread(tg, new Target(), "Child4");
	   
	   t1.start();
	   t2.start();
	   t3.start();
	   t4.start();
	   
	   System.out.println("Group Name is :"+tg.getName());
	   System.out.println("Total Running Threads under this group :"+tg.activeCount());

	}
}
---------------------------------------------------------------------
package com.ravi.thread_group;

class Tatkal implements Runnable
{
	@Override
	public void run() 
	{
		String name = Thread.currentThread().getName();
		System.out.println(name+" has booked the Ticket under Tatkal Scheme");
	}
	
}
class PremimumTatkal implements Runnable
{
	@Override
	public void run() 
	{
		String name = Thread.currentThread().getName();
		System.out.println(name+" has booked the Ticket under Premimum Tatkal Scheme");
		
	}	
}
public class ThreadGroupDemo2 {

	public static void main(String[] args) 
	{
		ThreadGroup tatkal = new ThreadGroup("Tatkal");
		ThreadGroup Premimumtatkal = new ThreadGroup("Premimum_Tatkal");
		
		Thread t1 = new Thread(tatkal,new Tatkal(), "Scott");
		Thread t2 = new Thread(tatkal,new Tatkal(), "Smith");
		
		Thread t3 = new Thread(Premimumtatkal,new PremimumTatkal(), "Alen");
		Thread t4 = new Thread(Premimumtatkal,new PremimumTatkal(), "John");
		
		t1.start(); t2.start(); t3.start(); t4.start();
		

	}

}

Note : By using this approach we can assign differnt target for different threads by uisng ThreadGroup.
--------------------------------------------------------------------
package com.ravi.thread_group;

public class ThreadGroupDemo3
{
	public static void main(String[] args) 
	{
		Thread t = Thread.currentThread();
		System.out.println(t.toString());
	}

}

Note : From the above program It is clear that main thread is running under main group.
---------------------------------------------------------------------
Daemon Thread [Service Level Thread]
------------------------------------
Daemon thread is a low- priority thread which is used to provide background maintenance.  

The main purpose of Daemon thread to provide services to the user thread.              

JVM can't terminate the program till any of the non-daemon (user) thread is active, once all the user thread will be completed then JVM will automatically terminate all Daemon threads, which are running in the background to support user threads.

The example of Daemon thread is Garbage Collection thread, which is running in the background for memory management.

In order to make a thread as a Daemon thread as well as to verify whether a thread is daemon thread or not, Java software people has provided the following two methods 

1) public void setDaemon(boolean on) : If the boolean value is true the thread will work as a Daemon thread.
   
2) public boolean isDaemon() : Will verify whether the thread is daemon thread OR user thread.
---------------------------------------------------------------------
public class DaemonThreadDemo1 
{
  public static void main(String[] args) 
	{
	    System.out.println("Main Thread Started...");

        Thread daemonThread = new Thread(() -> 
		{
            while (true) 
			{
                System.out.println("Daemon Thread is running...");
                try 
				{
                    Thread.sleep(1000);
                } 
				catch (InterruptedException e) 
				{
                    e.printStackTrace();
                }
            }
        });

        daemonThread.setDaemon(true); 
        daemonThread.start();

        
        Thread userThread = new Thread(() -> 
		{
            for (int i=1; i<=15; i++) 
			{
                System.out.println("User Thread: " + i);
                try 
				{
                    Thread.sleep(2000);
                } 
				catch (InterruptedException e) 
				{
                    e.printStackTrace();
                }
            }
        });

        userThread.start();

        System.out.println("Main Thread Ended...");
    }
}

Note : In the above program, first user thread will be completed then only JVM will automatically terminate the daemon thread.
---------------------------------------------------------------------
package com.ravi.thread_group;

public class IdDaemon {

	public static void main(String[] args) 
	{
		Thread main = Thread.currentThread();
		System.out.println(main.isDaemon());

		
		Thread t1 = new Thread();
		t1.setDaemon(true);
		System.out.println(t1.isDaemon());
		
	}

}
---------------------------------------------------------------------
public void interrupt() Method of Thread class :
--------------------------------------------------
It is a predefined non static method of Thread class. The main purpose of this method to disturb the execution of the Thread, if the thread is in waiting or sleeping state.

Whenever a thread is interupted then it throws InterruptedException so the thread (if it is in sleeping or waiting mode) will get a chance to come out from a particular logic.

Points :-
---------
If we call interrupt method and if the thread is not in sleeping or waiting state then it will behave normally.

If we call interrupt method and if the thread is in sleeping or waiting state then we can stop the thread  gracefully.

*Overall interrupt method is mainly used to interrupt the thread safely so we can manage the resources easily.

Methods :
---------
1) public void interrupt () :- Used to interrupt the Thread but the thread must be in sleeping or waiting mode.

2) public boolean isInterrupted() :- Used to verify whether thread is interrupted or not.

//Program :
------------
class Interrupt extends Thread
{
   @Override
   public void run()
	{
	   Thread t = Thread.currentThread();
	   System.out.println("Is thread interrupted : "+t.isInterrupted()); 
       
	   for(int i=1; i<=5; i++)
		{
		   System.out.println(i);  
		   
                   try
		   {
			Thread.sleep(1000);  //Java.lang.InterruptedException
			                     //interrupt flag value will become false
		   }                     
		   catch (InterruptedException e)
		   {
			   System.err.println(e);
		   }
		   
		}
	}
}
public class  InterruptThread
{
	public static void main(String[] args) 
	{
        Interrupt it = new Interrupt();
		System.out.println("Thread State is "+it.getState());  //NEW
		it.start();
		it.interrupt();  //main thread is interrupting the child thread
		                 //interrupt flag value will become true
	}
}

Note : In the above program main thread is interrupting child thread so interrupt flag value will become true, now once the child thread(in this program) will go into sleeping OR waiting state then child thread will throw InterruptedException and interrupt flag value will become false hence catch block would be executed only one time.
-----------------------------------------------------------------------
class Interrupt extends Thread
{
   @Override
   public void run()
	{
	   Thread t = Thread.currentThread();
	   System.out.println("Is thread interrupted : "+t.isInterrupted()); 
       
	   for(int i=1; i<=5; i++)
		{
		   System.out.println(i);  
		   
           try
		   {
			Thread.sleep(1000);  //Java.lang.InterruptedException
			                     //interrupt flag value will become false
		   }                     
		   catch (InterruptedException e)
		   {
			   System.err.println("Thread has Interrupted");
			   Thread.currentThread().interrupt(); //interrupt flag value will become true
		   }
		   
		}
	}
}
public class  InterruptThread
{
	public static void main(String[] args) 
	{
        Interrupt it = new Interrupt();
		System.out.println("Thread State is "+it.getState());  //NEW
		it.start();
		it.interrupt();  //main thread is interrupting the child thread
		                 //interrupt flag value will become true
	}
}

Note : Here in the catch block, we are interrupting the thread once again so the interrupt flag which was false will again become true so the Thread will throw InterruptedException (if the thread will go into sleeping OR Waiting state)
----------------------------------------------------------------------   
class Interrupt extends Thread
{
   @Override
   public void run()
	{
	   try
	   {
	    Thread.currentThread().interrupt(); //self interruption

	   for(int i=1; i<=10; i++)
		{
		   System.out.println("i value is :"+i);
		   Thread.sleep(1000);
		}

	   }
		catch (InterruptedException e)
		{
			System.err.println("Thread is Interrupted :"+e);
		}
		System.out.println("Child thread completed...");
	}
}
public class  InterruptThread1
{
	public static void main(String[] args) 
	{	
		Interrupt it = new Interrupt();
		it.start();	
	}
}

Note : catch block is not inside the for loop hence for loop will be executed only one time.
 ----------------------------------------------------------------------
 public class InterruptThread2
{
    public static void main(String[] args) 
	{
        Thread thread = new Thread(new MyRunnable());
        thread.start();
     
        try 
		{
          Thread.sleep(5000); //Main thread is waiting for 3 Sec
        } 
		catch (InterruptedException e) 
		{
            e.printStackTrace();
        }
        
       thread.interrupt();  
    }
}

class MyRunnable implements Runnable 
{
    @Override
    public void run() 
	{
        try 
		{
            while (!Thread.currentThread().isInterrupted())
			{
                System.out.println("Thread is running by locking the resource");
                Thread.sleep(500);
            }
        } 
		catch (Exception e) 
		{
            System.out.println("Thread interrupted gracefully.");
        } 
		finally 
		{
            System.out.println("Thread resource can be release here.");
        }
    }
}
----------------------------------------------------------------------
Deadlock :
------------
It is a situation where two or more than two threads are in blocked state forever, here threads are waiting to acquire another thread resource without releasing it's own resource.

This situation happens when multiple threads demands same resource without releasing its own attached resource so as a result we get Deadlock situation and our execution of the program will go to an infinite state as shown in the diagram. (03-May-25)

public class DeadlockExample
	{
  public static void main(String[] args) 
	 {
     String resource1 = new String("Ameerpet");  //(L1)
     String resource2 = new String("S R Nagar"); //(L2) 

    // t1 tries to lock resource1(L1) then resource2(L2)

    Thread t1 = new Thread() 
	 {
	  @Override
      public void run() 
		  {
			  synchronized (resource1) 
				  {
			   System.out.println("Thread 1: locked resource 1");
			      try 
				   { 
				   Thread.sleep(1000);
				   } 
				   catch (Exception e) 
				   {}				  
				
				//t1 thread is waiting here for Lock2
			   synchronized (resource2) //Nested synchronized block
			   {
				System.out.println("Thread 1: locked resource 2");
			   }
             }
      }
    };


    // t2 tries to lock resource2 then resource1
    Thread t2 = new Thread() 
	{
      @Override
      public void run() 
	  {
        synchronized (resource2) 
			{
          System.out.println("Thread 2: locked resource 2");
              try 
			  { 
			  Thread.sleep(1000);
			  } 
			  catch (Exception e) 
			  {}
			
			//t2 thread will wait for L1  (Resourse1)
          synchronized (resource1) //Nested synchronized block
		  {
            System.out.println("Thread 2: locked resource 1");
          }
        }
      }
    };    
    t1.start();
    t2.start();
  }
}
---------------------------------------------------------------------
In btween extends Thread and implements Runnable which one is better and Why ?

Ans : Both are the ways in java.lang package to create a Thread.
      In between extends Thread and implements Runnable, implements
      Runnable is more better approach due to the following reasons : 
      
      a) In extends Thread we cannot extend any other class (MI is not supported by using class) but in implements Runnable we can extend only one class.
      
      b) extends Thread provides tight coupling approach so to create multiple threads we need multiple sub class object on the other
      hand implements Runnable provides loose coupling approach so for creating multiple threads we need only sub class object.

       Example :
       Case 1 :
       --------
       class Test extends Thread
       {
       }
       
       Test t1 = new Test();
       t1.start();
       Test t2 = new Test();
       t2.start();
       
       Case 2:
       -------
       class UserThread implements Runnable
       {
       }
       
       UserThread ut = new UserThread();
       
       Thread t1 = new Thread(ut);
       Thread t2 = new Thread(ut);
       
       3) By using extends Thread we can't use Lambda Expression but using implements we can use Lambda Expression
       
       4) A class extends a Thread then all the Thread class methdos are available in the sub class but if we use implements Runnable then Thread class methos are not available.
	  
---------------------------------------------------------------------- 
volatile Keyword in java : [Reading the value of the variable from the main memory not from the cache memory] 
-----------------------------------------------------------------------
While working in a multithreaded environment multiple threads can perform read and write operation with common variable (chances of Data inconsistency so use synchronized OR AtomicInteger) concurrently.

In order to store the value temporarly, Every thread is having local cache memory (PC Register) but if we declare a variable with volatile modifier then variable's value is not stored in a thread's local cache; it is always read from the main memory.

So the conclusion is, a volatile variable value is always read from and written directly to the main memory, which ensures that changes made by one thread are visible to all other threads immediately.

package com.ravi.testing_demo;

class SharedData
{
    private volatile boolean flag = false; //FLAG VALUE WILL COME FROM MAIN MEMORY
    public void startThread()
    {
        Thread writer = new Thread(() ->
        {
            try
            {
            	System.out.println("Writer thread started");
                Thread.sleep(5000);  //Writer thread will go for 1 sec waiting state
                flag = true;
                System.out.println("Writer thread make the flag value as true");
            }
            catch (InterruptedException e)
            {
                e.printStackTrace();
            }
        });

        
        Thread reader = new Thread(() ->
        {
            while (!flag) //Cache memory still the value of flag is false
            {
               
            }
            System.out.println("Reader thread got the updated value");
        });

        writer.start();
        reader.start();
    }

}

public class VolatileExample
{    
    public static void main(String[] args)
    {
        new SharedData().startThread();
    }
}
-----------------------------------------------------------------------
05-05-2025
-----------
Remainig Methods Of Object class.
----------------------------------
1) protected native Object clone() throws CloneNotSupportedException :
-----------------------------------------------------------------------
It is a predefined non static method of Object class.

It is mainly used to create a duplicate copy of original object.

We can only perform clone() method operation, If the object is cloneable object that means that particular class must implements from java.lang.Cloneable interface which is a marker interface.

It is a protected method so we need to override the method and called the Object class clone() method.

It throws a checked exception i.e. java.lang.CloneNotSupportedException so handling is compulsory.

It follow deep copy concept so if we modify one object then another object remains unchanged.

clone() is method of Object class but not Cloneable interface, It is marker interface.
-----------------------------------------------------------------------
Steps we need to follow to perform clone operation :
----------------------------------------------------
1) The class must implements Cloneable interface
2) Override clone method [throws OR try catch]
3) In this Overridden method call Object class clone method
4) Perform downcasting at the time creating duplicate object
5) Two different objects are created [deep copy]

//Program how to create Duplicate Object for Customer 

package com.ravi.clone_method;

class Customer implements Cloneable
{
	private Integer custId;
	private String custName;
	
	public Customer(Integer custId, String custName) 
	{
		super();
		this.custId = custId;
		this.custName = custName;
		
	}
	
	@Override
	public String toString() 
	{
		return "Customer [custId=" + custId + ", custName=" + custName + "]";
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException
	{
		return super.clone();
	}

	public void setCustId(Integer custId) 
	{
		this.custId = custId;
	}

	public void setCustName(String custName) 
	{
		this.custName = custName;
	}
	
	
}

public class CloneMethodOperation 
{
	public static void main(String[] args) 
	{
		try
		{
			Customer c1 = new Customer(111, "Scott");
			Customer c2 = (Customer) c1.clone();
			
			System.out.println(c1); //111 Scott		
			System.out.println(c2); //111 Scott
			
			System.out.println("After Modification...");
			c1.setCustId(999);
			c1.setCustName("Alen");
			System.out.println(c1);	//999 Alen	
			System.out.println(c2); //111 Scott
			
		}
		catch(CloneNotSupportedException e)
		{
			e.printStackTrace();
		}
       
	}

}
-----------------------------------------------------------------------
proteced void finalize() throws Throwable :
--------------------------------------------
It is a predefined method of Object class.

Garbage Collector automatically call this method just before an object is eligible for garbage collection to perform clean-up activity.

Here clean-up activity means closing the resources associated with that object like file connection, database connection, network connection and so on we can say resource de-allocation.

Note :- JVM calls finalize method only one per object.

         This method is deprecated from java 9V.


package com.ravi.finalize;

class Product
{
	private Integer productId;
	private String productName;
	
	public Product(Integer productId, String productName) 
	{
		super();
		this.productId = productId;
		this.productName = productName;
	}

	@Override
	public String toString()
	{
		return "Product [productId=" + productId + ", productName=" + productName + "]";
	}
	
	
	@Override
	protected void finalize()
	{
		System.out.println("Product Object resourses closed successfully");
	}	
}
public class FinalizeDemo 
{
	public static void main(String[] args) throws InterruptedException 
	{
        Product p1 = new Product(111, "Laptop");
        System.out.println(p1);
        
        p1 = null;
        
        System.gc(); //Calling GC explicitly
        Thread.sleep(3000);
        
        System.out.println(p1);    

	}

}

Note : Here Product Object is eligible for GC then automatically finalize() method is invoked.

Calling finalize() method is an indication that Object is eligible for GC.
-----------------------------------------------------------------------
** What is the difference between final, finally and finalize()
----------------------------------------------------------------
final :
-------
It is used to provide some kind of restriction, by using final modifier we can declare our class, Method and variables as a final.

finally :
---------
If we open any resourse as a part of try block then it should compulsory closed inside finally block, [If We close the resourses inside try block, It is always Risky] for resourse handling purpose.

finalize() :
-------------
It is a method of Object class, We should override this method in the corresponding class to perform cleanup activity, JVM will automatically call this method just before object destruction.
=======================================================================
Logical Programming :
---------------------
