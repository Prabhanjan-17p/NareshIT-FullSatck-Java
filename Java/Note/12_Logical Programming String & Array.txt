Logical Programming :
---------------------
String handling in java :
--------------------------
It is a predefined class available in java.lang Package.
It is an immutable class so once we create String Object it is un-modifiable OR immutable (un-changed).

In Java we can create String Object by using 3 ways :
-------------------------------------------------------
1) By using String Literal :
   Example :   
   String str = "india";
   
2) By using new keyword :
   Example :
   String str1 = new String("Java");
   
3) By using Character Array : [Not recommended]
   Example :
   char ch[] = {'R','A','J'};

Working with String literal :
-----------------------------
With String Literal we have different Cases :
----------------------------------------------
Case 1 :
--------
package com.ravi.string_demo;

public class StringDemoCase1 {

	public static void main(String[] args) 
	{
		String str = "india";
		str.toUpperCase();
		System.out.println(str);
	}

}

Case 2 :
---------
package com.ravi.string_demo;

public class StringDemoCase2 {

	public static void main(String[] args) 
	{
		String s1 = "Data";
		s1 = s1.concat("base");
		System.out.println(s1);

	}

}

Case 3 :
--------
package com.ravi.string_demo;

public class StringDemoCase3 {

	public static void main(String[] args) 
	{
		String s3 = "Hyderabad";
		String s4 = s3.toUpperCase();		
		System.out.println(s3);
		System.out.println(s4);

	}

}
------------------------------------------------------------------------
Facts about String and it's memory :
-------------------------------------
In java Whenever we create a new String object by using String literal, first of all JVM will verify whether the String we want to create is pre-existing (already available ) in the String constant pool or not.

If the String is pre-existing (already available) in the String Constant pool then JVM will not create any new String object, the same old existing String object would be refer by new reference variable as shown in the diagram.

Note :- In SCP area we can't have duplicate String Object.[06-MAY]
------------------------------------------------------------------------** Why Strings are immutable in java :
---------------------------------------
As we know a String object in the String constant pool can be refer by multiple reference variables, if any of the reference variable will modify the String Object value then it would be very difficult for the another reference variables pointing to same String object to get the original value, what they have defined earlier as shown in the diagram.(06-MAY)

Along with that String we are using as a HashMap key so it must be immutable otherwise anyone can modify the original HashMap key.

That is the reason Strings are immutable in java.
------------------------------------------------------------------------
WAP in Java that describes String objects created by using String literals are not eligible for Garbage Collector.

package com.ravi.string_demo;

public class StringGC
{
	public static void main(String[] args) throws InterruptedException
	{
		String s1 = "india";
		System.out.println(s1+" : "+s1.hashCode());
		
		s1 = null;
		System.gc();
		Thread.sleep(5000);
		
		String s2 = "india";
		System.out.println(s2+" : "+s2.hashCode());
	}
}
------------------------------------------------------------------------
What is the difference bwteen the following two statements
--------------------------------------------------------------------

String x = "Naresh";   [Creating String by Literal]

String y = new String("Hyderabad"); [Creating String Object by new keyword]

------------------------------------------------------------------------String x = "Naresh"; 

It will create one String object and one reference variable and String object will be created in the String constant pool.Actually to place this String object in the SCP area JVM internally calls intern() method.
-------------------------------------------------------------------
String y = new String("Hyderabad");

It will create two String objects one is inside the heap memory(non SCP area) which will be reffered by y reference variable and the same String object will be placed in the String constant pool if it is not available there.
Hence two String Objects and one reference variable will be created.
(06 MAY)

Note :- IF WE ARE CREATING THE STRING BY USING LITERAL OR BY USING NEW KEYWORD, STRING OBJECTS ARE NOT ELIGIBLE 4 GC AS WELL NOT ELIGIBLE FOR MODIFICATION.
------------------------------------------------------------------------
Note :- JVM internally uses intern process to place the String object created by using new keyword inside SCP area[interning process]

public String intern()  :
---------------------------
It is a predefined method available in the String class. The main purpose of this method to return canonical representation for the string object that means String interning ensures that all strings having the same content use the same memory location.

The return type of this method is String

Case 1 :
---------
package com.ravi.string_demo;

public class StringInternDemo1 {

	public static void main(String[] args) 
	{
		String s1 = "Java";
		String s2 = new String("Java");
		
		System.out.println(s1==s2); //false		
		s2 = s2.intern();		
		System.out.println(s1==s2); //true

	}

}

Case 2:
-------
package com.ravi.string_demo;

public class StringInternDemo1 {

	public static void main(String[] args) 
	{
		String s1 = "Java";
		String s2 = new String("Java");
		
		System.out.println(s1==s2);		
		String s3 = s2.intern();		
		System.out.println(s1==s2);//false
		System.out.println(s1==s3);//true

	}

}
------------------------------------------------------------------------
07-05-2025
-----------
How many ways we can put the String into String constant pool :
---------------------------------------------------------------
The following are the ways to put the String into String constant pool :

1) String s1 = "india";
2) String s2 = new String("india").itern();
3) String s3 = "Tata" + "Nagar";  //Compile time constant
4) String s4 = String.valueOf("india");

package com.ravi.string_demo;

public class PlacingStringIntoSCP {

	public static void main(String[] args) 
	{
		String s1 = "Database";
		String s2 = "Data" + "base";
		String s3 = String.valueOf("Database");
		String s4 = new String("Database").intern();
		
		
		System.out.println(s1==s2);
		System.out.println(s1==s3);
		System.out.println(s1==s4);

	}

}
------------------------------------------------------------------------
Working with String class method :
-----------------------------------
1) public char charAt(int indexPosition) 
-----------------------------------------
It is used to fetch a single character from the given String based on the index position. Method return type is char.

package com.ravi.string_demo;

public class StringCommonMethod {

	public static void main(String[] args) 
	{
		   String x = "Hello Hyderabad";

	        char ch1 =  x.charAt(6); //H
			System.out.println(ch1); 

	}

}


2) pulic String concat(String str) :
------------------------------------
It is used to concatenate of two Strings. Method return type is String.
It can also be done by using + operator.

package com.ravi.string_demo;

public class StringCommonMethod {

	public static void main(String[] args) 
	{
		String s1 = "Data";
		String s2 = "base";
		String s3 = s1.concat(s2);  
		System.out.println("String after concatenation :"+s3);

        String s4 = "Tata";
		String s5 = "Nagar";
		String s6 = s4+s5;
		System.out.println("String after concatenation :"+s6);

        String s7 = "Naresh";
		System.out.println(s7.concat(" Technology"));	

	}

}


3) public boolean equals(Object obj) :
--------------------------------------
It is an overridden method, Overridden from Object class. It is used 
to compare two Strings based on the content.Method return type is 
boolean.


package com.ravi.string_demo;

public class StringCommonMethod {

	public static void main(String[] args) 
	{
		String username = args[0]; 

		if(username.equals("Ravi"))
		{
			System.out.println("Welcome Ravi");
		}
		else
		{
			System.out.println("Sorry! wrong username /Password");
		}

	}

}

4) public boolean equalsIgnoreCase(String str)
-----------------------------------------------
It is also used to compare two Strings based on the content by ignoring the case.Method return type is boolean.

package com.ravi.string_demo;

public class StringCommonMethod {

	public static void main(String[] args) 
	{
		String username = args[0]; 

		if(username.equalsIgnoreCase("Ravi"))
		{
			System.out.println("Welcome Ravi");
		}
		else
		{
			System.out.println("Sorry! wrong username /Password");
		}

	}

}

IQ
--
What is the difference between == operator and equals(Object obj) method of String class while comparing the String?

equals(object obj) method of String class compares two strings based on the content because it is an overriden method where as == operator compares two Strings based on the reference i.e memory address.

package com.ravi.string_demo;

public class IQ {

	public static void main(String[] args)
	{
		String str1 = "india";
		String str2 = new String("india");
		
		System.out.println(str1==str2); //false
		System.out.println(str1.equals(str2));//true

	}

}

5) public int length() :-
----------------------
The main purpose of this method to find out the length of the given String. The return type of this method is int. 

String str = "india"
       str.length(); //5

IQ :
----
class IQ 
{
	public static void main(String[] args) 
	{
	    String []x = new String[3];		
		System.out.println("Length is :"+x.length());
	}
}

Note : CE becoz x is an array variable and with array we have length property but not length() method.
------------------------------------------------------------------------
6) public String replace(CharSequence old, CharSequence new)
   public String replace(Char old, Char new)

It is an overloaded method. CharSequence is an interface. String, StringBuffer and StringBuilder class, all are implementing from 
CharSequence to provide loose coupling.

It is used to replace a particular character OR a string value from the 
given String. Method return type is String.

package com.ravi.string_demo;

public class StringCommonMethod {

	public static void main(String[] args) 
	{
		String x = "Manager";
		String y = x.replace("Man", "Dam");
		System.out.println(y);

		String a = "oxoxoxoxox";
		System.out.println("Original String :"+a);
		System.out.println("String after replacement :"+a.replace('x','X'));

	}

}

7) public int compareTo(String str) :
-------------------------------------
String class implements from Comparable<T> functional interface. It provides a single abstract method compareTo(T x). The return type of this method in int.
String class has overridden this compareTo(String str) methd to compare two Strings by using UNICODE value.
Comparing two Strings character by character by using UNICODE value is 
known as Lexicographical comparison or dictionary comparison or alphabetical comparison(String case). 

The return type of this method is int. It takes String as a parameter.

If s1 and s2 are two valid Strings 

if s1==s2  -> 0

if s1>s2  -> +ve

if s1<s2   -> -ve
-----------------------------------------------------------------------
package com.ravi.string_demo;

public class StringCommonMethod {

	public static void main(String[] args) 
	{
		String s1="Sachin";      //PQRS        S > R         
        String s2="Sachin";
        String s3="Ratan";  

	   System.out.println(s1.compareTo(s2)); //0
	   System.out.println(s1.compareTo(s3)); //1
	   System.out.println(s3.compareTo(s1)); //-1   

       String s4 = "Apple"; 
	   String s5 = "apple"; 
	   System.out.println(s4.compareTo(s5));  // -32  [65 to 97]
	   System.out.println(s5.compareTo(s4));  // 32 [97 to 65]

	   String s6 = "Ravi";
	   String s7 = "Rajiv";
	   System.out.println(s6.compareTo(s7)); //12

       }

}
-----------------------------------------------------------------------
public String substring(int startIndex) 
public String substring(int startIndex, int endIndex) 

The main purpose of this method to extract the part of the specified string based on the index position.

In this method the startIndex starts from 0 whereas endIndex starts from 1.

Both index will be inclusive for printing the value

If end index will be less than start index then we will get an exception i.e StringIndexOutOfBoundsException  
substring(5,2);

If start index and end index both are equal, nothing will print

Nither start index nor end index will accept (-ve) value otherwise StringIndexOutOfBoundsException.

package com.ravi.string_demo;

public class StringCommonMethod {

	public static void main(String[] args) 
	{
		String s1 = "Hyderabad";
		
		System.out.println(s1.substring(2)); //derabad
		System.out.println(s1.substring(3,6));//era
		System.out.println(s1.substring(4,4)); //Will not print anything
		System.out.println(s1.substring(6,2)); //StringIndexOutOfBoundsException
		System.out.println(s1.substring(-2,6)); //StringIndexOutOfBoundsException
	}

}
------------------------------------------------------------------------
public boolean isEmpty() :-
------------------------------
The main purpose of this method to check whether a String is empty or not. This method returns true if the String is empty that means length is 0, otherwise it will return false.

The return type of this method is boolean.

package com.ravi.string_demo;

public class StringCommonMethod {

	public static void main(String[] args) 
	{
		String str1 = "Java by James Gosling";
		String str2 = "";

		System.out.println(str1.isEmpty()); 
		System.out.println(str2.isEmpty()); 
	}

}
------------------------------------------------------------------------
hashCode() and equals(Object obj) :
------------------------------------
As we know there is a contract between hashCode() and equals(Object obj)

We should always override both the methods.

String class has overridden both the method and saying that : IF TWO STRING OBJECTS ARE SAME BASED ON THE equals(Object obj) overriden method of String class THEN THE HASHCODE OF BOTH THE STRING OBJECT must be same.

package com.ravi.string_demo;

public class StringCommonMethod 
{
	public static void main(String[] args) 
	{
		String str1 = "Java by James Gosling";
		String str2 = new String("Java by James Gosling");

		System.out.println(str1==str2);  //false
		System.out.println(str1.equals(str2)); //true
		System.out.println(str1.hashCode());
		System.out.println(str2.hashCode());
	}

}
------------------------------------------------------------------------
08-05-2025
-----------
public boolean isBlank() :
--------------------------
We have alraedy isEmpty() method which will verify the length of the 
String. 
isBlank() is introduced from java 11V.
It trurns true, If the String is empty OR it contais white space character.

package com.ravi.string_demo;

public class StringCommonMethod 
{
	public static void main(String[] args) 
	{
		System.out.println("".isBlank());
		System.out.println(" ".isBlank());
		System.out.println("\n ".isBlank());
		System.out.println("\t ".isBlank());
		System.out.println(" nit ".isBlank());
		System.out.println("..................");
		System.out.println("".isEmpty());
		System.out.println(" ".isEmpty());
		System.out.println("\n ".isEmpty());
		System.out.println("\t ".isEmpty());
		System.out.println(" nit ".isEmpty());
	}

}
------------------------------------------------------------------------
//public boolean startsWith(String prefix)
//public boolean endsWith(String suffix)


Both the methods are available in String class. 

startsWith() is used to verify that the given String is Starting with prefix String or not, if yes it will return true otherwise it will return false.

endsWith() is used to verify that the given String is ending with suffix String or not, if yes it will return true otherwise it will return false.

Both the methods are case-sensitive.

package com.ravi.string_demo;

public class StringCommonMethod 
{
	public static void main(String[] args) 
	{
		String s1 = "Virat Kohli";
		System.out.println(s1.startsWith("Vi"));
		
		String s2 = "Hyderabad";
		System.out.println(s2.endsWith("bad"));
	}

}

public int indexOf(String str) :
----------------------------------
The main purpose of this method to find out the index position of the specified String in the existing String.

It will serach the index position of the first occurrance of the specified String as a parameter.

It takes String as a parameter and return type of this method is int.

if the specified string is not available in the existing string then it will return -1.


public int lastIndexOf(String str) :
-------------------------------------
The main purpose of this method to find out the last index position of the Specified String in the existing String.

It will serach the index position of the last occurrance of the String.

It takes String as a parameter and return type of this method is int.

if the specified string is not available in the existing string then it will return -1.

package com.ravi.string_demo;

public class StringCommonMethod 
{
	public static void main(String[] args) 
	{
		String s1 = "it is a nice city";
		System.out.println(s1.indexOf("it"));
		System.out.println(s1.lastIndexOf("it"));
		System.out.println(s1.lastIndexOf("hyd"));
	}

}
------------------------------------------------------------------------
public String trim() :
----------------------
The main purpose of this method to remove the white spaces from the begning (heading) and end (trailing) from the String.

It will not remove any white space in the between the String. The return type of this method is String.

package com.ravi.string_demo;

public class StringCommonMethod 
{
	public static void main(String[] args) 
	{
		String s1="   Tata    ";  
		System.out.println(s1+"Nagar"); //       Tata      Nagar     

        s1 = "          Hello       Data        ";
		System.out.println(s1.trim() +"Base"); //Hello    DataBase	
	}

}
-----------------------------------------------------------------------
public []String split(String delimiter) :
------------------------------------------
The main purpose of this method to split or break the given String based on specified delimiter(Criteria).

The return type of this method is String array because It returns the collection of String tokens or multiple Strings.

package com.ravi.string_demo;

public class StringCommonMethod 
{
	public static void main(String[] args) 
	{
		String s1 = "Hyderabad is a nice city";
		String[] words = s1.split(" ");
		
		for(String word : words)
		{
			System.out.println(word);
		}
		
		System.out.println("...............");
		
		String s2 = "Hyderabad is an IT city"; 
		String[] split = s2.split("a");
		
		for(String x : split)
		{
			System.out.println(x);
		}
		
	}

}
-----------------------------------------------------------------------
Program on StringTokenizer class
---------------------------------
It is a predefined class available in java.util package.
It used to split the given String based on the delimiter.

Constructor :
-------------
public StringTokenizer(String str, String delimiter)
{
}

Methods :
-----------
public int countTokens()
public boolean hasMoreTokens()
public String nextToken()


package com.ravi.string_demo;

import java.util.StringTokenizer;

public class StringTokenizerDemo 
{
	public static void main(String[] args) 
	{
		String str = "Hyderabad is a nice city";
		
		StringTokenizer st = new StringTokenizer(str, " ");
		
		System.out.println("Total Tokens are :"+st.countTokens());

		while(st.hasMoreTokens())
		{
			System.out.println(st.nextToken());
		}
		
		
		
	}

}

-----------------------------------------------------------------------
public char[] toCharArray() :
------------------------------
The main purpose of this method to convert the given string into a sequence of characters. The returned array length is equal to the length of the string.

This method does not take any parameter and return type is character array.


package com.ravi.string_demo;

import java.util.StringTokenizer;

public class StringTokenizerDemo 
{
	public static void main(String[] args) 
	{
		String str = "Hyderabad is a nice city";
		
	   char[] charArray = str.toCharArray();
		
	   for(char ch : charArray)
	   {
		   System.out.print(ch+"\t");
	   }	
	
	}
}
-----------------------------------------------------------------------
public byte [] getBytes() :-
-------------------------------
It is a predefined method available in the String class. The main purpose of this method encode the string into bytes. It converts the string into a sequence of bytes and returns an array of bytes. 

package com.ravi.string_demo;

public class StringCommonMethod 
{
	public static void main(String[] args) 
	{
		String str = "ABCDEF";
		 
		byte[] bytes = str.getBytes();
		
		for(byte b : bytes)
		{
			System.out.println(b);
		}
		
		
	}

}
------------------------------------------------------------------------
StringBuffer :-
----------------
While working with String class the drawback is memory consumption is very high because it is immutable so whenever we want to perform some operation on the existing String Object, a new String object will be created.

In order to solve the problem of immutability as well as high memory consumption, java software people has introdued a separate class called StringBuffer available in java.lang package from 1.0 onwards.

StringBuffer is a mutable class so we can modify the existing String hence automatically the memory consumption will be low but we have some performance issue because almost all the methods of StringBuffer class are synchronized so at a time only one thread can access the method of StringBuffer hence it is Thread-safe. 

In order to solve this performance issue problem java software people has introduced StringBuilder class from 1.5v onwards.

StringBuilder :-
-----------------
It is a predefined class available in java.lang packge. It is also mutable class. The only difference between StringBuffer and StringBuilder is, almost all the methods of StringBuffer are synchronized where as all the methods of StringBuilder are non-synchronized hence performance wise StringBuilder is more better than StringBuffer.

Both the classes are sharing same API so, method name, return type, parameter list all are same.

**** What is the difference String, StringBuffer and StringBuilder?
Available in paint diagram [08-MAY-25]
------------------------------------------------------------------------
WAP that descrines StringBuffer and StringBuilder both are mutable object

package com.ravi.string_demo;

import java.time.LocalDate;
import java.util.Vector;

public class MutableDemo {

	public static void main(String[] args) 
	{
		String s1 = new String("Data");
		s1.concat("base");
		System.out.println(s1);
		
		StringBuffer buffer = new StringBuffer("Data");
		buffer.append("base");
		System.out.println(buffer);
		
		StringBuilder builder = new StringBuilder("Data");
		builder.append("base");
		System.out.println(builder);		
	}

}
------------------------------------------------------------------------
09-05-2025
-----------
public int capacity() :
-----------------------
It is used to define the initial buffer capacity of StringBuffer and StringBuilder.

The initial capacity is 16 so when we create StringBuffer object with no argument constructor then It can hold 16 characters.

When we append some charceters then the new capacity formula is :

new capacity = (current capacity + 1) * 2

package com.ravi.string_demo;

public class CapacityDemo {

	public static void main(String[] args) 
	{
		StringBuilder builder = new StringBuilder();
		System.out.println("Initial Capacity is :"+builder.capacity());
		
		StringBuffer buffer = new StringBuffer();
		System.out.println("Initial Capacity is :"+buffer.capacity()); //16
		
		StringBuffer buffer1 = new StringBuffer("india");
		System.out.println("Capacity is :"+buffer1.capacity()); //21
		
		buffer1.append("It is a great country. It is in Asia");
		System.out.println("Capacity is :"+buffer1.capacity()); //(21 + 1)*2 [44]
		
		

	}

}
-----------------------------------------------------------------------
//public StringBuffer insert(int position, String str)
//Based on the index position we can insert the String
public class Test27
{
public static void main(String args[])
	{	
		StringBuffer sb1=new StringBuffer("Hello");
		sb1.insert(1,"JSE");
		System.out.println(sb1);  //HJSEello

		StringBuilder sb2=new StringBuilder("Hello");
		sb2.insert(1,"JEE");
		System.out.println(sb2); //HJEEello 
	}
}
-----------------------------------------------------------------------
//public AbstractStringBuilder reverse()
//Used to reverse the given String
class Test28
{
	public static void main(String[] args) 
	{
		StringBuffer sb1=new StringBuffer("Hello");
		sb1.reverse();
		System.out.println(sb1); //olleH 

		StringBuilder sb2=new StringBuilder("Java");
		sb2.reverse();
		System.out.println(sb2);  //avaJ		
		}
}
---------------------------------------------------------------------//Program to demonstrate the performance of StringBuffer and  StringBuilder classes. 

How to calculate System current time :
---------------------------------------
System class has provided a predefined static method called currentTimeMillis() which will system current time in ms.This method 
return type is long.

public native static long currentTimeMillis()

package com.ravi.string_demo;

public class PerformanceComparison {

	public static void main(String[] args)
	{		
		long startTime = System.currentTimeMillis(); 
		
		StringBuffer buffer = new StringBuffer("Java");
		
		for(int i=0; i<=1000000; i++)
		{
			buffer.append("Technology");
		}
		
		long endTime = System.currentTimeMillis(); 
		
		System.out.println("The total time taken by StringBuffer is :"+(endTime - startTime)+ "ms");
		
		
       startTime = System.currentTimeMillis(); 
		
		StringBuilder builder = new StringBuilder("Java");
		
		for(int i=0; i<=1000000; i++)
		{
			builder.append("Technology");		
		}
		
		endTime = System.currentTimeMillis(); 
		
		System.out.println("The total time taken by StringBuilder is :"+(endTime - startTime)+ "ms");
		
	}

}
=====================================================================

What is a Variable in java ?
----------------------------
A variable is a name given for the memory location.

What is the drawback of an ordinary variable ?
-----------------------------------------------
An Ordinary variable can hold only one value at a time in random memory location.

Example :

int x = 10; //Valid
int y = 90,67; //Invalid

We want to hold multiple values in a contiguous memory location then we should use another concept called Array.

What is Array in java :
-----------------------
An array is a container object that holds a fixed number of values of a single type in ordered collection. 

It can store multiple values in a single variable. In Java due to upcasting concept, array can also hold hetrogeneous types of data.

Example :-

int []x = {12,78,45,34,90}; //Homogeneous

Object [] obj = {12,"Ravi",null, 90.56}; //Hetrogeneous

In Java array is an object so it is created as a part of HEAP memory which can hold primitive types as well as reference type. Since array is an object, it is created during runtime.

The length of an array is established when the array is created. After creation, its length is fixed.

Characteristics of an Array :
-----------------------------
1) Homogeneous Elements:
------------------------
All elements in an array must be of the same data type but by using upcasting we can accept Hetrogeneous elements also.

2) Fixed Size :
----------------
Once an array is created, its size cannot be changed.(size is nothing but number of elements are available in the array)

3) Indexed Based:
-----------------
We can store and access the elements using index (arr[0] for the first element, arr[1] for the second, etc.)

  a) How to find first and last index position element
     size = 10;  [length = 10]

     startIndex -> [0]         = firstElement
     endIndex   -> [length -1] = lastElement

4) Stored in Contiguous Memory:
--------------------------------
Array elements are stored in adjacent memory locations, improving access speed (Cache Memory). 

5) Stored in Heap Memory:
-------------------------
Arrays are objects in Java and are stored in the heap, even if declared inside a method.

6) Default Values:
------------------
If an array is declared but not initialized, Java assigns default values because it is a reference data type.

7) Efficient Retrieval:
-----------------------
Direct access to elements using an index provides fast data retrieval (O(1) time complexity).


Drawback of an array :
----------------------
1) Fixed in size
2) Insertion OR deletion at the begning or middle is O(n)
3) No predefined method support.
--------------------------------------------------------------------
10-05-2025
----------
Types of Array in java :
------------------------
Basically in java we have 2 types of Array 

1) 1D OR Single Diemensional Array ([])
2) 2D OR Multi Diemensional Array  ([][])

Note : We have also jagged array which is a Multi Diemensional Array
       where each row can have different number of columns.
       
Working with Single Diemensional Array :
----------------------------------------
The following are the ways to work with Single Diemension Array 

Example 1 :
-----------
The most common way to create an array object is by using new keyword 

       int []arr = new int[10]; //Array of Primitive
       
       Student []students = new Student[5]; //Array of reference 
       
Note : Here all the array index will be initialized with default value.

Example 2 :
------------
We can also create an array by using new keyword with Inline Initialization [We can initializ the array in the same line]

     int []arr = new int[]{12, 90, 67, 45}

Note : Here instead of default value, array will be initialized with 
       user value in the same line.
       
The above statement is duplicate expression because we already know 
the data type and size (from left side of = operator) so java has 
introduced another style of creating array which is known as 
Anonymous array.

Example 3 :
-----------
              int []arr = {12,90,56,34}; //Anonymous Array


Now finally we can write [] symbol left OR right side as well as 
space does not matter.

int[]  num1;
int [] num2;
int  []num3;
int num4[];
int num5 [];

Some important Points :
------------------------
int x; //Primitive
int []y; //Object

======================================================================
WAP to show how to retrieve the array data by using ordinary for loop, for each loop and Arrays class toString() method.

java.util.Arrays class has provided a predefined static method called 
toString() for int array the signature of the method is :

   public static String toString(int []arr)

package com.ravi.array_programs;

import java.util.Arrays;

public class ArrayRetrieval {

	public static void main(String[] args) 
	{
		int []x = new int[3];
		x[0] = 10;
		x[1] = 20;
		x[2] = 30;
		System.out.println("By using Ordinary for loop");
		
		for(int i=0; i<x.length; i++)
		{
			System.out.println(x[i]);
		}
		
		System.out.println("By using  loop each loop");
		int []y = new int[] {100,200,300};
		
		for(int a : y)
		{
			System.out.println(a);
		}
		
		System.out.println("By using  toString() method");
		
		int []z = {1000, 2000,3000};
		System.out.println(Arrays.toString(z)); //"

	}

}
-----------------------------------------------------------------------
WAP to java JNI encoding standard

package com.ravi.array_programs;

public class ArrayDemo1 {

	public static void main(String[] args) 
	{
		byte b[] = new byte[2]; 
		System.out.println(b.getClass().getName()); //[B
		
		short s[] = new short[2];
		System.out.println(s.getClass().getName()); //[S
		
		int i[] = new int[2];
		System.out.println(i.getClass().getName()); //[I
		
		long l[] = new long[2];
		System.out.println(l.getClass().getName()); //[J
		
		float f[] = new float[2];
		System.out.println(f.getClass().getName()); //[F
		
		double d[] = new double[2];
		System.out.println(d.getClass().getName()); //[D
		
		char ch[] = new char[2];
		System.out.println(ch.getClass().getName()); //[C
		
		boolean bool[] = new boolean[2];
		System.out.println(bool.getClass().getName()); //[Z		
		
		Integer str[] = new Integer[2];
		System.out.println(str.getClass().getName()); //[Ljava.lang.Integer
	}

}
-----------------------------------------------------------------------
WAP to show array length property is created during runtime
package com.ravi.array_programs;

import java.util.Arrays;

public class ArrayDemo2 {

	public static void main(String[] args) 
	{
	   int arr[] = {12,89,90};
	   System.out.println("Array Elements are :"+Arrays.toString(arr));
	   System.out.println("Length is :"+arr.length);
	   System.out.println("First index value is "+arr[0]);
	   System.out.println("Last index value is "+arr[arr.length - 1]);

	}

}
---------------------------------------------------------------------
3) WAP to print the array elements in reverse order. (user input)

package com.ravi.array_programs;

import java.util.Arrays;
import java.util.Scanner;

public class ArrayDemo3 {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the size of the Array :");
		int size = sc.nextInt();
		
		int []arr = new int[size];
		
		//Initializing the array elements :
		
		for(int i=0; i<arr.length; i++)
		{
			System.out.print("Enter the element at "+i+"th index :");
			arr[i] = sc.nextInt();
		}
		
		System.out.println("Original Array :"+Arrays.toString(arr));
		System.out.println("Printing the Array in Reverse order :");
		
		for(int i = arr.length-1; i>=0; i--)
		{
			System.out.println(arr[i]);			
		}	

	}

}
-----------------------------------------------------------------------
4) WAP to find the sum of all elements of the array.
5) WAP to calculate the student marks and find out the average.
-----------------------------------------------------------------------
6) WAP to find the minimum element in the Array (Stream also)

Approach 1 :
------------
By using Traditional Approach :
--------------------------------
package com.ravi.array_programs;

import java.util.Scanner;

class FindMinimum
{
	public static void getMinimumValue(int []x) //9 5 7 2
	{
		int min = x[0];
		
		for(int i=1; i<x.length; i++)
		{
			if(min > x[i])
			{
				min = x[i];
			}
		}
		System.out.println("Minimum value is :"+min);		
	}	
}
public class ArrayDemo6 {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the size of the Array :");
		int size = sc.nextInt();
		
		int []arr = new int[size];
		
		//Initializing the array elements :
		
		for(int i=0; i<arr.length; i++)
		{
			System.out.print("Enter the element at "+i+"th index :");
			arr[i] = sc.nextInt();
		}
		
		FindMinimum.getMinimumValue(arr);

	}

}

New Approach to find minimum value using java 8 features :
------------------------------------------------------------
package com.ravi.array_programs;

import java.util.Arrays;

public class ArrayDemo6 {

	public static void main(String[] args) 
	{
		int []arr = {12,90,56,9,34,-1};		
		Arrays.stream(arr).min().ifPresent(System.out::println);
	}
}
=======================================================================
7) WAP to find the maximum element in the Array. [Traditinal + New ]	
-----------------------------------------------------------------------
8) WAP to modify the value of an array.[Change Array Element]
package com.ravi.array_programs;

import java.util.Arrays;

class ChangeArrayElement
{
	public static int[] modifyElement(int []x) //arr = {100,200,30,40,50}
	{
		x[0] = 100;
		x[1] = 200;
		
		return x;
	}
}


public class ArrayDemo8 {

	public static void main(String[] args) 
	{
		int []arr = {10,20,30,40,50};		
		System.out.println("Original Array :"+Arrays.toString(arr));
		
		
		int[] modifyElement = ChangeArrayElement.modifyElement(arr);
		System.out.println("After Modification :"+Arrays.toString(modifyElement));
		
		System.out.println("Original Array after Modification :"+Arrays.toString(arr));
	}

}
-----------------------------------------------------------------------
 9) Create Book Object to access Book class properties through Book array index.

package com.ravi.array_programs;

class Book
{
	String author;
	String title;
}


public class ArrayDemo9 
{
	public static void main(String[] args) 
	{
		Book books[] = new Book[3];
		books[0] = new Book();
		books[1] = new Book();
		books[2] = new Book();
		
		books[0].title = "Java";
		books[0].author = "James Gosling";
		
		books[1].title = "C";
		books[1].author = "Kishore Sir";
		
		books[2].title = "Spring";
		books[2].author = "Natraj Sir";
		
		int index = 0;
		
		while(index < books.length)
		{
			System.out.print(books[index].title);
			System.out.print(" by ");
			System.out.println(books[index].author);
			index++;
		}
		

	}

}
----------------------------------------------------------------------




  
