Collections Framework : (40-45% IQ)
-----------------------------------
Collections framework is nothing but handling individual Objects(Collection Interface) and Group of objects(Map interface).

We know only object can move from one network to another network.  

A collections framework is a class library to handle group of Objects.

It is implemented by using java.util package.

It provides an architecture to store and manipulate group of objects.

All the operations that we can perform on data such as searching, sorting, insertion and deletion can be done by using collections framework because It is the data structure of Java.

The simple meaning of collections is single unit of Objects.
-------------------------------------------------------------
It provides the following sub interfaces :

1) List (Accept duplicate elements)
2) Set (Not accepting duplicate elements)
3) Queue (Storing and Fetching the elements based on some order i.e FIFO)

Note : Collection is a predefined interface available in java.util package where as Collections is a predefined  utility class which is available from JDK 1.2V which contains only static methods (Constructor is private)

----------------------------------------------------------------
Collection Hierarchy :
-----------------------
Hierarchy is available in Paint Diagram (13-MAY-25)
-------------------------------------------------------------------------
14-05-2025
-----------
Methods of Collection interface :
----------------------------------
a) public boolean add(E element) : It is used to add an item/element in the in the collection.

b) public boolean addAll(Collection c) :- It is used to insert the specified collection elements in the existing collection(For merging the Collection)

c) public boolean retainAll(Collection c) :- It is used to retain all the elements from existing element. (Common Element)

d) public boolean removeAll(Collection c) :- It is used to delete all the elements from the existing collection.

e) public boolean remove(Object element) :- It is used to delete an element from the collection based on the object.

f) public int size() :- It is used to find out the size of the Collection [Total number of elements available]

g) public void clear() :- It is used to clear all the elements at once from the Collection.

All the above methods of Collection interface will be applicable to all the sub interfaces like List, Set and Queue.
-------------------------------------------------------------------------
List<E> interface :
-------------------
It is the sub interface of SequenceCollection<E> (Available from java 21) which extends from Collection<E> available from JDK 1.2V

List<E> interface accepts duplicate elements.

It stores the elements based on the index because List<E> interface internally uses Array concept. [List interface classes are implemented by Linear Data structure]

It uses Array and LinkedList data structure so we can perform sorting 
operation.
------------------------------------------------------------------------
List interface Hierarchy :
---------------------------
Hierarchy is Available in Diagram [14th May]

Behaviour of List interface Specific classes :
-----------------------------------------------
It stores the elements based on the index position.

It stores everything in the form of Object.

It uses Linear(Dynamic Array + LinkedList) data structure.

By using generics we can eliminate compilation warning as well as we can 
hold homogeneous and hetrogeneous types of element by using <Object>

Few classes of List interface are DYNAMICALLY GROWABLE.
-----------------------------------------------------------------------
15-05-2025
-----------
List interface Methods :
------------------------
1) public boolean isEmpty() :- Verify whether List is empty or not

2) public void clear() :- Will clear all the elements, Basically List will become empty.

3) public int size() :- To get the size of the Collections(Total number of elements are available in the collection)

4) public void add(int index, Object o) :- Insert the element based on the index position.

5) public boolean addAll(int index, Collection c) :- Insert the Collection based on the index position

6) public Object get(int index) :- To retrieve the element based on the index position


7) public Object set(int index, Object o) :- To override or replace the existing element based on the index position

8) public Object remove(int index) :- remove the element based on the index position

9) public boolean remove(Object element) :-  remove the element based on the object element, It is the Collection interface method extended by List interface 

10) public int indexOf() :- index position of the element

11) public int lastIndex() :- last index position of the element

12) public Iterator iterator() :- To fetch or iterate or retrieve the elements from Collection in forward direction only.

13) public ListIterator listIterator() :- To fetch or iterate or retrieve the elements from Collection in forward and backward direction.

------------------------------------------------------------------------
How many ways we can fetch OR retrieve the Object from the Collection :
-----------------------------------------------------------------------
There are 10 ways to retrieve the Collection Object which are as follows :

1) By using toString() method of respective class (JDK 1.0)
2) By using Ordinary for Loop (JDK 1.0)
3) By using for-Each loop (JDK 1.5)
4) By using Enumeration interface(JDK 1.0)
5) By using Iterator interface (JDK 1.2)
6) By using ListIterator interface (JDK 1.2)
*7) By using forEach(Consumer<T> cons) method (JDK 1.8)
*8) By using SplIterator interface (JDK 1.8)
*9) By using Method Reference (JDK 1.8)
**10) By using Stream API (stream())  (JDK 1.8)

Among all these, Enumeration, Iterator, ListIterator and SplIterator are 
the cursors so It can move from one direction to another direction.
--------------------------------------------------------------------------
Enumeration :
----------------
It is a predefined interface available in java.util package from JDK 1.0 onwards(Legacy interface).

We can use Enumeration interface to fetch or retrieve the Objects one by one from the Collection because it is a cursor.

We can create Enumeration object by using elements() method of the legacy Collection class. Internally it uses anonymous inner class object.

public Enumeration elements();   

Enumeration interface contains two methods :
---------------------------------------------------
1) public boolean hasMoreElements() :- It will return true if the Collection is having more elements.

2) public Object nextElement() :- It will return collection object so return type is Object and move the cursor to the next line.

Note :- It will only work with legacy Collections classes.
--------------------------------------------------------------------------
Iterator<E>
-----------
It is a predefined interface available in java.util package available from 1.2 version.

It is used to fetch/retrieve the elements from the Collection in forward direction only because it is also a cursor.

It is also using private inner class i.e Itr class.

public Iterator iterator();

Example :
-----------
 Iterator itr = listOfCity.iterator();

Now, Iterator interface has provided two methods 


public boolean hasNext() :- 

It will verify, the element is available in the next position or not, if available it will return true otherwise it will return false.

public Object next() :- It will return the collection object and move the cursor to the element object.
--------------------------------------------------------------------------
ListIterator<E> interface :
-------------------------
It is a predefined interface available in java.util package and it is the sub interface of Iterator available from JDK 1.2v.

It is used to retrieve the Collection object in both the direction i.e in forward direction as well as in backward direction. Here the inner class name is LstItr class extends from Itr class.

public ListIterator listIterator();

Example :
-----------
ListIterator lit =   listOfCity.listIterator();

1) public boolean hasNext() :- 
It will verify the element is available in the next position or not, if available it will return true otherwise it will return false.

2) public Object next() :- It will return the next position collection object.

3) public boolean hasPrevious() :- 
It will verify the element is available in the previous position or not, if available it will return true otherwise it will return false.


4) public Object previous () :- It will return the previous position collection object.

Note :- Apart from these 4 methods we have add(), set() and remove() method in ListIterartor interface.  

public default void forEach(Consumer<T> cons) :
-----------------------------------------------
It is a predfined default method available in java.lang.Iterable interface.

forEach(Consumer<T> cons) method of Iterable interface internally uses for each loop.

It takes Consumer as a parameter.


Case 1 :
---------
package com.ravi.collection;

import java.util.Vector;
import java.util.function.Consumer;

public class ForEachMethodInternalDemo1 {

	public static void main(String[] args) 
	{
		Vector<String> listOfCity = new Vector<>();
		 listOfCity.add("Hyderabad");
	     listOfCity.add("Kolkata");
	     listOfCity.add("Pune");
	     listOfCity.add("Indore");
	     
	     //Anonymous inner class
	     Consumer<String> cons = new Consumer<String>() 
	     {			
			@Override
			public void accept(String t) 
			{
				System.out.println(t.toUpperCase());				
			}
		 };
	     
         listOfCity.forEach(cons);
		 
		 
		 
	}

}



Case 2 :
---------
package com.ravi.collection;

import java.util.Vector;
import java.util.function.Consumer;

public class ForEachInternalDemo2 
{
	public static void main(String[] args) 
	{
		Vector<String> listOfCity = new Vector<>();
		 listOfCity.add("Hyderabad");
	     listOfCity.add("Kolkata");
	     listOfCity.add("Pune");
	     listOfCity.add("Indore");
	     
	     //Lambda Approach
	     Consumer<String> cons = city -> System.out.println(city.toUpperCase());
	     
         listOfCity.forEach(cons);
		 
		 
		 
	}
}

Case 3 :
---------

package com.ravi.collection;

import java.util.Vector;

public class ForEachInternalDemo3 
{
	public static void main(String[] args) 
	{
		Vector<String> listOfCity = new Vector<>();
		 listOfCity.add("Hyderabad");
	     listOfCity.add("Kolkata");
	     listOfCity.add("Pune");
	     listOfCity.add("Indore");
	          
         listOfCity.forEach(city -> System.out.println(city.toUpperCase()));
		 
		 
		 
	}
}
--------------------------------------------------------------------------
Spliterator interface :
-----------------------
It is available from JDK 1.8V

It is used to iterate the element over the Collection by eliminating hasNext() and next()

It contains a default method forEachRemaining(Consumer<T> cons).

It internally uses do-while loop.

--------------------------------------------------------------------------Stream interface :
------------------
Stream is a predefined interface available in java.util.stream sub package.

Collection interface has provided a method called stream(), the return type of this method is Stream interface.

public Stream stream();
-------------------------------------------------------------------------
-------------------------------------------------------------------------
//Program that describes how we can fetch the Collection Object by 
all possible ways :
  
package com.ravi.collection;

import java.util.Enumeration;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Spliterator;
import java.util.Vector;

public class RetrievingCollectionObject {

	public static void main(String[] args)
	{
		 Vector<String> listOfCity = new Vector<>();
		 listOfCity.add("Hyderabad");
	     listOfCity.add("Kolkata");
	     listOfCity.add("Pune");
	     listOfCity.add("Indore");
	     listOfCity.add("Mumbai");	    
	     listOfCity.add("Haryana");	    
	     
	     System.out.println("By using 1) toString() Method :");
	     System.out.println(listOfCity.toString());
	     
	     
	     System.out.println("By using 2) Ordinary For Loop:");
	     
	     for(int i=0; i<listOfCity.size(); i++)
	     {
	    	 System.out.println(listOfCity.get(i));
	     }
	     
	     System.out.println("By using 3) For Each Loop:");
	     
	     for(String city : listOfCity)
	     {
	    	 System.out.println(city);
	     }
	     
	     System.out.println("By using 4) Enumeration Interface :");

	     Enumeration<String> elements = listOfCity.elements();
	     
	     while(elements.hasMoreElements())
	     {
	    	 System.out.println(elements.nextElement());
	     }
	     	     
	     System.out.println("By using 5) Iterator Interface :");	     
	     Iterator<String> itr = listOfCity.iterator();	     
	     itr.forEachRemaining(city -> System.out.println(city));
	     
	     System.out.println("By using 6) ListIterator Interface :");
	     
	     ListIterator<String> listItr = listOfCity.listIterator();
	     
	     System.out.println("IN FORWARD DIRECTION :");
	     
	     while(listItr.hasNext())
	     {
	    	 System.out.println(listItr.next());
	     }
	     
	     System.out.println("IN BACKWARD DIRECTION :");
	     
	     while(listItr.hasPrevious())
	     {
	    	 System.out.println(listItr.previous());
	     }
	     
	     System.out.println("By using 7) for Each Method :");
	     listOfCity.forEach(city -> System.out.println(city));
	     
	     System.out.println("By using 8) Spliterator interface :");	     
	     Spliterator<String> spliterator = listOfCity.spliterator();
	     spliterator.forEachRemaining(city -> System.out.println(city));
	     
	     
	     System.out.println("By using 9) Method Reference :");	   
	     listOfCity.forEach(System.out::println);
	     
	     System.out.println("By using 10) Method Reference :");	 
	     listOfCity.stream().forEach(System.out::println);
	     
	}

}
//"
==========================================================================
Working with List interface implemented class :
-----------------------------------------------
Inside List interface we have 4 implemented classes :

 1) Vector
 2) Stack
 3) ArrayList
 4) LinkedList
 

Vector<E> :
-----------
public class Vector<E> extends AbstractList<E>  implements List<E>, Serializable, Clonable, RandomAccess

Vector is a predefined class available in java.util package under List interface. 

Vector is always from java means it is available from jdk 1.0 version.

It can accept duplicate, null, homogeneous as well as hetrogeneous elements.

Vector and Hashtable, these two classes are available from jdk 1.0, remaining Collection classes were added from 1.2 version. That is the reason Vector and Hashtable are called legacy(old) classes.

The main difference between Vector and ArrayList is, ArrayList methods are not synchronized so multiple threads can access the method of ArrayList where as on the other hand most the methods are synchronized in Vector so performance wise Vector is slow.

*We should go with ArrayList when Threadsafety is not required on the other hand we should go with Vector when we need ThreadSafety for reterival operation.

Here Iterator is Fail Fast Iterator.

It stores the elements on index basis.It is dynamically growable with initial capacity 10. The next capacity will be 20 i.e double of the first capacity.

new capacity = current capacity * 2;

It implements List, Serializable, Clonable, RandomAccess interfaces.

Constructors in Vector :
-------------------------
We have 4 types of Constructor in Vector

1) Vector v1 = new Vector();        
     It will create the vector object with default capacity is 10        
    
2) Vector v2 = new Vector(int initialCapacity);     
     Will create the vector object with user specified capacity.

3) Vector v3 = new Vector(int initialCapacity, int capacityIncrement);     
     Eg :-     Vector v = new Vector(1000,5);

     Initially It will create the Vector Object with initial capacity 1000 and then when  the capacity will be full then increment by 5 so the next capacity would be 1005, 1010 and so on.

 4) Vector v4 = new Vector(Collection c);
    We can achieve loose coupling.
    
--------------------------------------------------------------------------
package com.ravi.vector;

import java.util.Collections;
import java.util.Vector;

public class VectorDemo {

	public static void main(String[] args) 
	{
		
		Vector<String> listOfCity = new Vector<>();
		listOfCity.add("Hyderabad");
		listOfCity.add("Pune");
		listOfCity.add("Indore");
		listOfCity.add("Bhubneswar");
		listOfCity.add("Kolkata");
			
		 System.out.println("Before Sorting :"+listOfCity);
		 Collections.sort(listOfCity);	
	     System.out.println("After Sorting :"+listOfCity);
		
		
        //Removing based on the index
        listOfCity.remove(3);
		System.out.println("After removing by index :"+listOfCity);
		       
        //Retrieving by using forEach() Method
		listOfCity.forEach(city -> System.out.println(city));
		
		System.out.println("Size is :"+listOfCity.size());
		
		System.out.println("Is list empty :"+listOfCity.isEmpty());
       
	}

}

Note : Collections utility class has provided sort(List<E> list) static method.
--------------------------------------------------------------------------
//Vector Program on capacity

package com.ravi.vector;

import java.util.*;

public class VectorDemo1 {
	public static void main(String[] args)
	{
		Vector<Integer> v = new Vector<>(100,10); 
		
		System.out.println("Initial capacity is :" + v.capacity());

		for (int i = 0; i < 100; i++) 
		{
			v.add(i);
		}

		System.out.println("After adding 100 elements  capacity is :" + v.capacity()); 
		
		v.add(101);
		System.out.println("After adding 101th elements  capacity is :" + v.capacity());

		for(int i=0; i<v.size(); i++)
		{
			if(i%5==0)
			{
				System.out.println();
			}
			System.out.print(v.get(i)+"\t");
		}

		
	}
}
--------------------------------------------------------------------------
package com.ravi.vector;

//Array To Collection
import java.util.*;
public class VectorDemo2
{
	public static void main(String args[])
	{
		Vector<Integer> v = new Vector<>();  
		
		int x[]={22,20,10,40,15,58};
		
 
      //Adding array values to Vector
		for(int i=0; i<x.length; i++)
		{
			v.add(x[i]);
		}		
		Collections.sort(v);
		System.out.println("Maximum element is :"+Collections.max(v));
		System.out.println("Minimum element is :"+Collections.min(v));
		System.out.println("Vector Elements :");
		
		v.forEach(y -> System.out.println(y));
		
		System.out.println(".....................");
		Collections.reverse(v);
		System.out.println("Reverse Order");
		v.forEach(y -> System.out.println(y));
		
		//How to convert Vector to Array
		  System.out.println("Object Array");
		  Object[] array = v.toArray();
		  System.out.println(Arrays.toString(array));	
	}
}
--------------------------------------------------------------------------
package com.ravi.vector;

import java.util.Vector;

//Custom Object

record Employee(Integer id, String name, Double salary)
{	
}

public class VectorDemo3
{
	public static void main(String[] args) 
	{
	   Vector<Employee> listOfEmployee = new Vector<>();
	   listOfEmployee.add(new Employee(333, "Aryan", 65000D));
	   listOfEmployee.add(new Employee(444, "Zuber", 45000D));
	   listOfEmployee.add(new Employee(111, "Satish", 55000D));
	   listOfEmployee.add(new Employee(222, "Jay", 52000D));
	   
	   listOfEmployee.forEach(emp -> System.out.println(emp));  
	  
	}
}
-----------------------------------------------------------------------
19-05-2025
----------
//Program to describe that ArrayList is better than Vector in performance

package com.ravi.vector;

import java.util.ArrayList;
import java.util.Vector;

public class VectorDemo4 
{
	public static void main(String[] args) 
	{
		long startTime = System.currentTimeMillis();
		
		ArrayList<Integer> al = new ArrayList<Integer>();
		
		for(int i=0; i<1000000; i++)
		{
			al.add(i);
		}
		
		long endTime = System.currentTimeMillis();
		
		System.out.println("Total Time taken by ArrayList class :"+(endTime - startTime)+" ms");
		
       startTime = System.currentTimeMillis();
		
		Vector<Integer> v1 = new Vector<Integer>();
		
		for(int i=0; i<1000000; i++)
		{
			v1.add(i);
		}
		
		endTime = System.currentTimeMillis();
		
		System.out.println("Total Time taken by Vector class :"+(endTime - startTime)+" ms");
			
		
	}
}
------------------------------------------------------------------------
package com.ravi.vector;

import java.util.Arrays;
import java.util.Collections;
import java.util.OptionalInt;
import java.util.Vector;

public class VectorDemo5
{

	public static void main(String[] args) 
	{
		Vector<String> listOfCity = new Vector<>();
		listOfCity.add("Surat");
		listOfCity.add("Pune");
		listOfCity.add("Ahmadabad");
		listOfCity.add("Vanaras");
		
		Collections.sort(listOfCity);
		
		listOfCity.forEach(System.out::println);
		
		
		System.out.println(".............");
		
		Vector<Integer> listOfNumbers = new Vector<>();
		listOfNumbers.add(500);
		listOfNumbers.add(900);
		listOfNumbers.add(400);
		listOfNumbers.add(300);
		listOfNumbers.add(800);
		listOfNumbers.add(200);
		listOfNumbers.add(100);	
		
		System.out.println("Original Data...");
		System.out.println(listOfNumbers);
		
		
		System.out.println("Ascending Order...");
		Collections.sort(listOfNumbers);
		System.out.println(listOfNumbers);
		
		System.out.println("Descending Order...");
		
		Collections.sort(listOfNumbers, Collections.reverseOrder());
		System.out.println(listOfNumbers);
		
		//Converting Our Vector(Collection Object) into Array
		Vector<String> listOfFruits = new Vector<>();
		listOfFruits.add("Orange");
		listOfFruits.add("Apple");
		listOfFruits.add("Mango");
		
		Object[] fruits = listOfFruits.toArray();
		System.out.println(Arrays.toString(fruits));
		
				
	}

}

Sorting Data in Ascending Order :Collections.sort(List<E> list)
In descending Order :Collections.sort(List<E> list, Collections.reverseOrder())

Collections.reverseOrder() method return type is Comparator interface.
------------------------------------------------------------------------
package com.ravi.vector;

import java.util.Scanner;
import java.util.Vector;

public class VectorDemo6
{
    public static void main(String[] args) 
    {        
        Vector<String> toDoList = new Vector<>();

        Scanner scanner = new Scanner(System.in);

        int choice;
        do 
        {
            System.out.println("To Do List Menu:");
            System.out.println("1. Add Task");
            System.out.println("2. View Tasks");
            System.out.println("3. Mark Task as Completed");
            System.out.println("4. Exit");
            
            System.out.print("Enter your choice: ");

            choice = scanner.nextInt(); 
            scanner.nextLine(); 

            switch (choice) 
            {
                case 1:
                    // Add Task
                    System.out.print("Enter task description: ");
                    String task = scanner.nextLine();  
                    toDoList.add(task);
                    System.out.println("Task added successfully!\n");
                    break;
                case 2:
                    // View Tasks
                    System.out.println("To Do List:");
                    for (int i = 0; i < toDoList.size(); i++) 
                    {
                      System.out.println((i + 1) + ". " + toDoList.get(i));
                    }
                    System.out.println();
                    break;
                case 3:
                    // Mark Task as Completed
                    System.out.print("Enter task number to mark as completed: ");
                    int taskNumber = scanner.nextInt(); //1
                    if (taskNumber >= 1 && taskNumber <= toDoList.size()) 
                    {
                        String completedTask = toDoList.remove(taskNumber - 1);
                        System.out.println("Task marked as completed: " + completedTask + "\n");
                    } 
                    else {
                        System.out.println("Invalid task number!\n");
                    }
                    break;
                case 4:
                    System.out.println("Exiting ToDo List application. Goodbye!");
                    break;
                default:
                    System.out.println("Invalid choice. Please enter a valid option.\n");
            }

        } 
        while (choice != 4);

       
        scanner.close();
    }
}
----------------------------------------------------------------------
default Iterator asIterator() :
-------------------------------
This method is added in Enumeration interface from java 9V to support 
backward compatibility(suppoting old version)

package com.ravi.vector;

import java.util.Enumeration;
import java.util.Iterator;
import java.util.Vector;

record Product(int productId, String productName)
{
	
}

public class VectorDemo7 
{
	public static void main(String[] args) 
	{
		Vector<Product> listOfProduct = new Vector<>();
		listOfProduct.add(new Product(111, "Laptop"));
		listOfProduct.add(new Product(222, "Mobile"));
		listOfProduct.add(new Product(333, "Camera"));
		listOfProduct.add(new Product(444, "Bag"));
		listOfProduct.add(new Product(555, "Watch"));
	
		
		Enumeration<Product> ele = listOfProduct.elements(); 
		Iterator<Product> itr = ele.asIterator();
		itr.forEachRemaining(System.out::println);
		
	}

}
-----------------------------------------------------------------------
*** What is Fail Fast and Fail safe Iterator ?
----------------------------------------------
While retrieving the object from the collection by using Itearor interface or for each loop, if at any point of time the original structure is going to modify after the creation of Itearator then we will get java.util.ConcurrentModificationExacption.

We will not get this exception, If it is modified by Iterators OWN 
method like add() OR remove().

package com.ravi.vector;

import java.util.Iterator;
import java.util.Vector;

class Concurrent extends Thread
{
	private Vector<String> cities;  //1000x

	public Concurrent(Vector<String> cities) 
	{
		super();
		this.cities = cities;
	}
	
	@Override
	public void run()
	{
		try
		{
			Thread.sleep(2000);
		}
		catch(InterruptedException e)
		{
			e.printStackTrace();
		}
		
		cities.add("Goa");
	}	
}


public class VectorDemo8 
{
	public static void main(String[] args) throws InterruptedException 
	{
		Vector<String> listOfCity = new Vector<>(); //listOfCity = 1000x
		listOfCity.add("Surat");
		listOfCity.add("Pune");
		listOfCity.add("Ahmadabad");
		listOfCity.add("Vanaras");
		listOfCity.add("Hyderabad");
		
		Concurrent cons = new Concurrent(listOfCity);
		cons.start();
		
		Iterator<String> itr = listOfCity.iterator();
		while(itr.hasNext())
		{
			System.out.println(itr.next());
			Thread.sleep(500);
		}
				
	}

}

Note : We will get java.util.ConcurrentModificatioinException

package com.ravi.vector;

import java.util.Iterator;
import java.util.Spliterator;
import java.util.concurrent.CopyOnWriteArrayList;

class Concurrent extends Thread
{
	private CopyOnWriteArrayList<String> cities;  //1000x

	public Concurrent(CopyOnWriteArrayList<String> cities) 
	{
		super();
		this.cities = cities;
	}
	
	@Override
	public void run()
	{
		try
		{
			Thread.sleep(1000);
		}
		catch(InterruptedException e)
		{
			e.printStackTrace();
		}
		
		cities.add("Goa");
	}	
}


public class VectorDemo8 
{
	public static void main(String[] args) throws InterruptedException 
	{
		CopyOnWriteArrayList<String> listOfCity = new CopyOnWriteArrayList<>(); //listOfCity = 1000x
		listOfCity.add("Surat");
		listOfCity.add("Pune");
		listOfCity.add("Ahmadabad");
		listOfCity.add("Vanaras");
		listOfCity.add("Hyderabad");
		
		Concurrent cons = new Concurrent(listOfCity);
		cons.start();
		
		Iterator<String> itr = listOfCity.iterator();
		while(itr.hasNext())
		{
			System.out.println(itr.next());
			Thread.sleep(500);
		}
		System.out.println("..............");
		
		Spliterator<String> spliterator = listOfCity.spliterator();
		spliterator.forEachRemaining(System.out::println);		
	}

}
=======================================================================
Stack<E> :
-----------
Stack<E> :
------------
public class Stack<E> extends Vector<E>

It is a predefined class available in java.util package. It is the sub class of Vector class introduced from JDK 1.0 so, It is also a legacy class. 

It is a linear data structure that is used to store the Objects in LIFO (Last In first out) order.

Inserting an element into a Stack is known as push operation  where as extracting an element from the top of the stack is known as pop operation.

It throws an exception called java.util.EmptyStackException, if Stack is empty and we want to fetch the element.

It has only one constructor as shown below

Stack s = new Stack(); 

Will create empty Stack Object.
------------------------------------------------------------------------------------
Methods :
----------
public E push(Object o) :- To insert an element in the bottom of the Stack.

public E pop() :- To remove and return the element from the top of the Stack.

public E peek() :- Will fetch the element from top of the Stack without removing.

public boolean empty() :- Verifies whether the stack is empty or not (return type is boolean)

public int search(Object o) :- It will search a particular element in the Stack and it returns OffSet position (int value). If the element is not present in the Stack it will return -1
----------------------------------------------------------------------
//Program to insert and fetch the elements from stack
package com.ravi.stack;
import java.util.*;
public class Stack1
{
      public static void main(String args[])
      {
            Stack<Integer> s = new Stack<>();
             try
             {
                  s.push(12);
                  s.push(15);
				  s.push(22);
				  s.push(33);
				  s.push(49);				  
				  System.out.println("After insertion elements are :"+s); 
               
                  System.out.println("Fetching the elements using pop method");
                  System.out.println(s.pop());
                  System.out.println(s.pop()); 
                  System.out.println(s.pop());  
                  System.out.println(s.pop());  
                  System.out.println(s.pop());
                                                                        
                 			  	
	 			  System.out.println("After deletion elements are :"+s);//[]
				  
				  System.out.println("Is the Stack empty ? :"+s.empty());  
              }
			catch(EmptyStackException e)
			{
			   e.printStackTrace();
			} 
		
      }
}
----------------------------------------------------------------------
//add(Object obj) is the method of Collection
package com.ravi.stack;
import java.util.*;
public class Stack2
{
      public static void main(String args[])
      {
            Stack<Integer> st1 = new Stack<>();
            st1.add(10);
            st1.add(20);      
            st1.forEach(x -> System.out.println(x));

            Stack<String> st2 = new Stack<>();
            st2.add("Java");  
            st2.add("is");
            st2.add("programming");
            st2.add("language"); 
            st2.forEach(x -> System.out.println(x));

            Stack<Character> st3 = new Stack<>();
            st3.add('A');  
            st3.add('B');
            st3.forEach(x -> System.out.println(x));

            Stack<Double> st4 = new Stack<>();
            st4.add(10.5);
            st4.add(20.5);               
            st4.forEach(x -> System.out.println(x));          
      }  
}
----------------------------------------------------------------------
package com.ravi.stack;
import java.util.Stack;  

public class Stack3
{  
	public static void main(String[] args)   
		{  
			Stack<String> stk= new Stack<>();  
			stk.push("Apple");  
			stk.push("Grapes");  
			stk.push("Mango");  
			stk.push("Orange");  
			System.out.println("Stack: " + stk);  
			
			String fruit = stk.peek(); 			
			System.out.println("Element at top: " + fruit);  
			System.out.println("Stack elements are : " + stk); 
		}  
}  
----------------------------------------------------------------------
//Searching an element in the Stack
package com.ravi.stack;
import java.util.Stack;  
public class Stack4
{  
	public static void main(String[] args)   
		{ 		       
			Stack<String> stk= new Stack<>();  //Apple   Grapes   Mango
			stk.push("Apple");  
			stk.push("Grapes");  
			stk.push("Mango"); 			
			System.out.println("Offset Position is : " + stk.search("Mango"));	//1		
			System.out.println("Offser Position is : " + stk.search("Banana")); //-1
		    System.out.println("Is stack empty ? "+stk.empty());	//false
			
			System.out.println("Index Position is : " + stk.indexOf("Mango")); //2	    
		
		}  
}  
----------------------------------------------------------------------
20-05-2025
-----------
ArrayList<E> :
--------------
public class ArrayList<E> extends AbstractList<E> implements List<E>,
Cloneable, Serializable, RandomAccess


It is a predefined class available in java.util package under List interface from java 1.2v.

It accepts duplicate,null, homogeneous and hetrogeneous elements.

It is dynamically growable array.

It stores the elements on index basis so it is simillar to dynamic array.

Initial capacity of ArrayList is 10. The new capacity of Arraylist can be calculated by using the  formula
new capacity = (current capacity * 3)/2 + 1  [Almost 50% increment]

*All the methods declared inside an ArrayList is not synchronized so multiple thread can access the method of ArrayList so performance wise it is good.

*It is highly suitable for fetching or retriving operation when duplicates are allowed and Thread-safety is not required.

Here Iterator is Fail Fast Iteartor.

It implements List,Serializable, Clonable, RandomAccess interfcaes.

hashCode() and equlas(Object obj) methods are overridden.

Constructor of ArrayList :
----------------------------
In ArrayList we have 3 types of Constructor:
Constructor of ArrayList :

1) ArrayList al1 = new ArrayList();
   Will create ArrayList object with default capacity 10.

2) ArrayList al2 = new ArrayList(int initialCapacity);
   Will create an ArrayList object with user specified Capacity

3) ArrayList al3 = new ArrayList(Collection c)
   We can copy any Collection interface implemented class data to the current object   reference (Coping one Collection data to another)
---------------------------------------------------------------------
//How to add ArrayList element

package com.ravi.arraylist;

import java.util.ArrayList;

public class ArrayListDemo
{
    public static void main(String[] args) 
    {
        
        ArrayList<Integer> numbers = new ArrayList<>(100);
                
        numbers.add(100);
        numbers.add(200);
        numbers.add(300);
        numbers.add(400);
        
        int sum = 0;
        
        for (int number : numbers) 
        {
            sum += number;
        }        
        System.out.println("Sum of numbers: " + sum);
    }
}
---------------------------------------------------------------------
//Custom Object
package com.ravi.arraylist;

import java.util.ArrayList;

record Customer(Integer custId, String custName, Double custBill)
{	
}

public class ArrayListDemo1
{
	public static void main(String[] args) 
	{
		ArrayList<Customer> listOfCustomer = new ArrayList<>();
		listOfCustomer.add(new Customer(111, "Scott", 12000D));
		listOfCustomer.add(new Customer(222, "Smith", 12000D));
		listOfCustomer.add(new Customer(333, "Alen", 12000D));
		listOfCustomer.add(new Customer(444, "John", 12000D));
		
		listOfCustomer.forEach(System.out::println);		
		
	}
}

----------------------------------------------------------------------
package com.ravi.arraylist;

//Program to merge and retain of two collection addAll()   retainlAll()
import java.util.*;
public class ArrayListDemo2  
	{
		public static void main(String args[]) 
		{ 
		  ArrayList<String> al1=new ArrayList<>();
		  al1.add("Ravi");
		  al1.add("Rahul");
		  al1.add("Rohit");		  
		  
		  ArrayList<String> al2=new ArrayList<>();
		  al2.add("Pallavi");
		  al2.add("Sweta");
		  al2.add("Puja");		  

		  al1.addAll(al2);  

          al1.forEach(str -> System.out.println(str.toUpperCase()) );

        System.out.println(".................................");

		  ArrayList<String> al3=new ArrayList<>();
		  al3.add("Ravi");
		  al3.add("Rahul");
		  al3.add("Rohit");		  
		  
		  ArrayList<String> al4=new ArrayList<>();
		  al4.add("Pallavi");
		  al4.add("Rahul");
		  al4.add("Raj");
		  
		  al3.retainAll(al4);  

          al3.forEach(x -> System.out.println(x));		  
   }
}
---------------------------------------------------------------------
How to create fixed length Array and Immutable List :
------------------------------------------------------
1) How to create a fixed length Array :
---------------------------------------
java.util.Arrays class has provided a predefined static method
asList(T ...x), It will create a fixed length array and the return type of this method is List interface. 

In this fixed length array we can't perform add or remove opeartion otherwise we will get  java.lang.UnsupportedOperationException but we can replace the existing element.

       public static List<E> asList(T ...x);

package com.ravi.arraylist;

import java.util.Arrays;
import java.util.List;

public class FixedLengthArray 
{
	public static void main(String[] args)
	{
		List<Integer> listOfNumber = Arrays.asList(1,2,3,4,5,6,7);
		System.out.println(listOfNumber);
		
		//listOfNumber.remove(0); //java.lang.UnsupportedOperationException
		//listOfNumber.add(8); //java.lang.UnsupportedOperationException
		
		listOfNumber.set(0, 100);
		System.out.println(listOfNumber);

	}

}

2) Immutable List :
-------------------
List interface has provided a predefined static method called 
of(T ...x) available from java 9V.

It will create an immutable list, return type of this method is 
List<E>. Once it is created after that we can't pefrom any kind of operation like add(), remove() or replace [set(int index, Object obj)] otherwise we will get java.lang.UnsupportedOperationException

package com.ravi.arraylist;

import java.util.List;

public class ImmutableList {

	public static void main(String[] args) 
	{
		List<Integer> listOfNumber = List.of(1,2,3,4,5,6);		
		listOfNumber.set(0,100); //java.lang.UnsupportedOperationException
		listOfNumber.add(7); //java.lang.UnsupportedOperationException
		listOfNumber.remove(0); //java.lang.UnsupportedOperationException
	}

}
----------------------------------------------------------------------
//Program to fetch the elements in forward and backward 
//direction using ListIterator interface

package com.ravi.arraylist;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.ListIterator;

public class ArrayListDemo3   
{                             
public static void main(String args[])
  {
	 List<String> listOfName = Arrays.asList("Rohit","Akshar","Pallavi","Sweta"); //Length is fixed
	 
	 Collections.sort(listOfName);
	 
	 //Fetching the data in both the direction
	 ListIterator<String> lst = listOfName.listIterator();
	 
	 System.out.println("In Forward Direction..");	 
	 while(lst.hasNext())
	 {
		System.out.println(lst.next()); 
	 }
	 System.out.println("In Backward Direction..");	 
	 while(lst.hasPrevious())
	 {
		System.out.println(lst.previous()); 
	 }
	 
  }
}
-----------------------------------------------------------------------
ArrayListDemo4 [Pending Program] [Serialization and Deserialization]


---------------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;
import java.util.Collections;

public class ArrayListDemo5
{
    public static void main(String[] args)
    {        
        ArrayList<String> cities = new ArrayList<>();

        cities.add("Hyderabad");
        cities.add("Delhi");
        cities.add("Banglore");
        cities.add("Chennai");
        
        System.out.println("Before sorting: " + cities);        
        
        
        cities.sort((s1,s2)-> s1.compareTo(s2));
        System.out.println("In Ascending Order :"+cities);          

       
        Collections.sort(cities, (s1,s2)-> s2.compareTo(s1));
        System.out.println("In Descending Order :"+cities);      
      

    }
}
---------------------------------------------------------------------
21-05-2025
-----------
package com.ravi.arraylist;

//Program on ArrayList that contains null values as well as we can pass 
//the element based on the index position
import java.util.ArrayList;
import java.util.LinkedList;
public class ArrayListDemo6
{
	public static void main(String[] args) 
	{
		ArrayList<Object> al = new ArrayList<>(); //Generic type
		al.add(12);
		al.add("Ravi");
		al.add(12);		
		al.add(3,"Hyderabad"); 
		al.add(1,"Naresh");
		al.add(null);
		al.add(11);
		System.out.println(al);  //12 Naresh Ravi 12 Hyderabad null 11
	}
}
----------------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;
import java.util.List;

record Professor(String name, String specialization)
{
}

class Department 
{
	private String departmentName;
	private List<Professor> professors;	
	
	public Department(String departmentName)
	{
		this.departmentName = departmentName;
		professors = new ArrayList<Professor>(); //Composition
	}

	public String getDepartmentName()
	{
		return this.departmentName;
	}

	public List<Professor> getProfessors() 
	{
		return this.professors;
	}
	
	//Adding the Prof. in the department
	public void addProfessor(Professor prof)
	{
		this.professors.add(prof);
	}	
}

public class ArrayListDemo7
{
    public static void main(String[] args) 
    {
       Department dept = new Department("Computer Science");
       dept.addProfessor(new Professor("Dr. Smith", "Java"));	
       dept.addProfessor(new Professor("Dr. Alen", "Networking"));	
       dept.addProfessor(new Professor("Dr. Scott", "Database"));	
       
       System.out.println("Professors in :"+dept.getDepartmentName());
       dept.getProfessors().forEach(System.out::println);       
       
       Department department = new Department("Civil Engineering");
       department.addProfessor(new Professor("Dr. Raj", "Engineering Drawing"));	
       department.addProfessor(new Professor("Dr. Samir", "Concrete Technology"));	
       department.addProfessor(new Professor("Dr. Ankit", "Environmental Engineering"));	
       
       System.out.println("Professors in :"+department.getDepartmentName());
       department.getProfessors().forEach(System.out::println);
       
      
    }
}
----------------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;

public class ArrayListDemo8
{
    public static void main(String[] args) 
    {
        ArrayList<String> original = new ArrayList<>();
        original.add("BCA");
        original.add("MCA");
        original.add("BBA");
        
        System.out.println("By using clone Method");
        @SuppressWarnings("unchecked")
		ArrayList<String> cloned = (ArrayList<String>) original.clone();
        System.out.println(cloned);    
        
        
      System.out.println("By using Copy Constructor");
      ArrayList<String> copyConstr = new ArrayList<String>(original);
      System.out.println(copyConstr);      
       
    }
}
----------------------------------------------------------------------
public List subList(int fromIndex, int toIndex) :
--------------------------------------------------
It is used to fetch/retrieve the part of the List based on the given index. The return type of this method is List, Here fromIndex is inclusive and toIndex is exclusive.

public boolean contains(Object element) :
------------------------------------------
It is used to find the given element object in the corresponsing List, if available it  will return true otherwise false.

public default boolean removeIf(Predicate<T> filter) [JDK 1.8]
----------------------------------------------------------------
It is used to remove the elements based on boolean condition passed as a Predicate.

----------------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;
import java.util.List;

public class ArrayListDemo9 {

	public static void main(String[] args) 
	{
		ArrayList<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        list.add(5);
        list.add(6);
        list.add(7);
        list.add(8);
        list.add(9);
        list.add(10);
        
        //public List subList(int fromIndex, int toIndex)
        List<Integer> subList = list.subList(2, 5);  //3 4 5
        System.out.println(subList);
        
       
        System.out.println("........................");
         
        //public boolean contains(Object obj)
        boolean contains = list.contains(10);
        System.out.println(contains);
       
      
        System.out.println("........................");
        
        //public int indexOf(Object obj)
        System.out.println(list.indexOf(1));  
        
        System.out.println("................");
        
        //public void removeIf(Predicate<T> p)
        list.removeIf(num -> num%2==1);
        list.forEach(System.out::println);         
        
	}
}

//Program on removeIf(Predicate<T> p) method :
-----------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class RemoveIfDemo {

	public static void main(String[] args) 
	{
		
		List<String> listOfNames = new ArrayList<String>();
		listOfNames.add("Raj");
		listOfNames.add("Rohit");
		listOfNames.add("Rohan");
		listOfNames.add("Ankit");
		listOfNames.add("Scott");
		
		System.out.println("Original List :"+listOfNames);
				
		listOfNames.removeIf(str -> str.startsWith("R"));
		
		System.out.println("After Removing :"+listOfNames);		
	}
}
-----------------------------------------------------------------------
public void trimToSize() 
--------------------------
[Shrinks the capacity equal to the size, Dynamically Growable]

Used to reduce the capacity equals to the current size and then when we
add more elements then dynamically Growable

public void ensureCapacity(int minCapacity)
--------------------------------------------
Increase the capacity of the ArrayList to avoid frequent resizing. 

The minCapacaity parameter will specify that ArrayList will definetly hold the number of elements specified in the parameter of ensureCapacity() method.

After using  ensureCapacity() method, still it is dynamically growable.

package com.ravi.arraylist;

import java.util.ArrayList;
import java.util.RandomAccess;

public class ArrayListDemo10 {

	public static void main(String[] args) 
	{
		ArrayList<String> list = new ArrayList<>(100); 
        list.add("Java");
        list.add("World");          
        
        //public void trimToSize()
        list.trimToSize(); //Shrinks the capacity equal to the size
        System.out.println("Trimmed List Size: " + list.size()); 
        
        System.out.println(".........................");
        
        
        ArrayList<Integer> listOfNumber = new ArrayList<>();

        // public void ensureCapacity(int minCapacity)
        //Increase the capacity of the ArrayList to avoid frequent resizing.
        listOfNumber.add(999);
        
        
        
        listOfNumber.ensureCapacity(100);

        for (int i = 0; i < 50; i++) 
        {
        	listOfNumber.add(i);
        }

        System.out.println("List size: " + listOfNumber.size());
    }

}
=======================================================================
Time Complexity of ArrayList :
-------------------------------
The time complexity of ArrayList to insert OR delete an element from the middle OR Begning (not at last) would be O(n) [Big O of n] because 'n' number of elements will be re-located so, it is not a good choice to perform insertion and deletion operation in the middle OR begning of the List. 

On the other hand time complexity of ArrayList to retrieve an element from the List would be O(1) because by using get(int index) method we can retrieve the element randomly from the list. ArrayList class implements RandomAccess marker interface which provides the facility to fetch the elements Randomly. [21-MAY-25]

IF WE WANT TO PERFORM FREQUENET INSERTION OR DELETION IN THE LIST THEN WE SHOULD ANOTHER DATA STRUCTURE I.E LinkedList Data Structure.

***LinkedList :
--------------
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable

It is a predefined class available in java.util package under List interface from JDK 1.2v.

It is ordered by index position like ArrayList except the elements (nodes) are doubly linked to one another. This linkage provide us new method for adding and removing the elements from the middle of LinkedList.

It stores the elements in non-contiguous memory location.

*The important thing is, LikedList may iterate more slowely than ArrayList but LinkedList is a good choice when we want to insert or delete the elements frequently in the list.

From jdk 1.6 onwards LinkedList class has been enhanced to support basic queue operation by implementing Deque<E> interface.

LinkedList methods are not synchronized.

It inserts the elements by using Doubly linked List so insertion and deleteion is very easy.

ArrayList is using Dynamic array data structure but LinkedList class is using LinkedList (Doubly LinkedList) data structure.

At the time of searching an element, It will start searching from Head node OR tail node means closer one based on the index.

**Here Iterators are Fail Fast Iterator.

Constructor:
-------------
It has 2 constructors 

1) LinkedList list1 = new LinkedList();
    It will create a LinkedList object with 0 capacity.

2) LinkedList list2 = new LinkedList(Collection c);
    Interconversion between the collection

Methods of LinkedList class:
-------------------------------
1) void addFirst(Object o)
2) void addLast(Object o)

3) Object getFirst()
4) Object getLast()

5) Object removeFirst()
6) Object removeLast()

The time complexcity for insertion and deletion is  O(1) The time complexcity for seraching O(n) because it serach the elemnts using node reference. 
----------------------------------------------------------------------
package com.ravi.collection;

import java.util.LinkedList;

public class SinglyLinkedList 
{
	static class Node
	{
		int item;
		Node next;  //next [ANN -> Address of Next Node]
		
		public Node(int item)
		{
			this.item = item;
			this.next = null;
		}	
	}

	public static void main(String[] args) 
	{
		Node n1 = new Node(100);
		Node n2 = new Node(200);
		Node n3 = new Node(300);
		
		n1.next = n2;
		n2.next = n3;
		
		
		System.out.println(n1.item);
		System.out.println(n1.next.item);
		System.out.println(n1.next.next.item);	
		
		LinkedList l = null;
		
	}

}
----------------------------------------------------------------------
package com.ravi.linked_list;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
public class LinkedListDemo
{
 public static void main(String args[])
 { 
      LinkedList<Object> list=new LinkedList<>();
	  list.add("Ravi");
	  list.add("Vijay");
	  list.add("Ravi");
	  list.add(null);
	  list.add(42);	  
	  
	  System.out.println("1st Position Element is :"+list.get(1));
	  //Iterator interface 	  
	   Iterator<Object> itr = list.iterator();
	   itr.forEachRemaining(System.out::println); //JDK 1.8	 
  }
}
----------------------------------------------------------------------
package com.ravi.linked_list;

import java.util.*;
public class LinkedListDemo1
{
      public static void main(String args[])
      {
           LinkedList<String> list= new LinkedList<>(); //generic
           list.add("Item 2");//2  
           list.add("Item 3");//3   
           list.add("Item 4");// 4  
           list.add("Item 5");// 5  
           list.add("Item 6");// 6 
           list.add("Item 7");// 7
           
           list.add("Item 9"); //10  

           list.add(0,"Item 0");//0
           list.add(1,"Item 1"); //1
           
           

           list.add(8,"Item 8");//8
		   list.add(9,"Item 10");//9
            System.out.println(list);
			
         
			list.remove("Item 5"); 
			  
			  System.out.println(list);
			  
			  
			   list.removeLast(); 
			    System.out.println(list);
			   
			     list.removeFirst(); 
			    System.out.println(list);
			   
			  list.set(0,"Ajay"); //set() will replace the existing value
			  list.set(1,"Vijay"); 
			  list.set(2,"Anand"); 
			  list.set(3,"Aman");
			  list.set(4,"Suresh"); 
			  list.set(5,"Ganesh");
			  list.set(6,"Ramesh");
			  list.forEach(x -> System.out.println(x)); 		
			
      } 
}
---------------------------------------------------------------------
package com.ravi.linked_list;

//Methods of LinkedList class
import java.util.LinkedList;
public class LinkedListDemo2
{
    public static void main(String[] argv) 
    {
          LinkedList<String> list = new LinkedList<>();
          
          list.addFirst("Ravi");  // Ravi  Rahul  Anand
          list.add("Rahul"); 
          list.addLast("Anand");	
          
          System.out.println(list.getFirst()); 
          System.out.println(list.getLast()); 
          
          list.removeFirst();
          list.removeLast(); 
          
          System.out.println(list); //[Rahul]        
         
    }
}
----------------------------------------------------------------------
package com.ravi.linked_list;
//ListIterator methods (add(), set(), remove())
import java.util.*;
public class LinkedListDemo3 
{
	public static void main(String[] args) 
	{
		LinkedList<String> city = new LinkedList<> ();
         city.add("Kolkata");
		 city.add("Bangalore");
		 city.add("Hyderabad");
		 city.add("Pune");
		 System.out.println(city); 
		
		ListIterator<String> lt = city.listIterator();

          while(lt.hasNext())
		  {
			String cityName =  lt.next();

			if(cityName.equals("Kolkata"))
			{
                 lt.remove();
			}
			else if(cityName.equals("Hyderabad"))
			{
                 lt.add("Ameerpet");
			}
			else if(cityName.equals("Pune"))
			{
                 lt.set("Mumbai");
			}
		}
		city.forEach(System.out::println);
		
	}
}

Here there is no ConcurrentModificationException because ListIterator is modifying the structure by it's own method hence there is no problem because it is internal structure modification.
---------------------------------------------------------------------
23-05-2025
----------
package com.ravi.linked_list;

//Insertion, deletion, displaying and exit

import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class LinkedListDemo4
{
 public static void main(String[] args)
	{
      List<Integer> linkedList = new LinkedList<>();
      Scanner scanner = new Scanner(System.in);

        while (true) 
		{
          System.out.println("Linked List: " + linkedList); //[]
          System.out.println("1. Insert Element");
          System.out.println("2. Delete Element");
		  System.out.println("3. Display Element");
          System.out.println("4. Exit");
          System.out.print("Enter your choice: ");

          int choice = scanner.nextInt();
          switch (choice) 
			{
              case 1: 
                  System.out.print("Enter the element to insert: ");
                  int elementToAdd = scanner.nextInt();
                  linkedList.add(elementToAdd);
                  break;
              case 2:
                  if (linkedList.isEmpty()) 
					{
                      System.out.println("Linked list is empty. Nothing to delete.");
                  } 
					else 
					{
                      System.out.print("Enter the element to delete: ");
                      int elemenetToDelete = scanner.nextInt(); 
                      boolean remove = linkedList.remove(Integer.valueOf(elemenetToDelete));
                         
                      
                       if(remove)
                       {
                    	   System.out.println("Element "+elemenetToDelete+ " is deleted Successfully" );
                       }
                       else
                       {
                    	   System.out.println("Element "+elemenetToDelete+" not available is the LinkedList");
                       }
                    
                  }
                  break;
				case 3:
					System.out.println("Elements in the linked list.");
                    linkedList.forEach(System.out::println);
				     break;
              case 4:
                  System.out.println("Exiting the program.");
                  scanner.close();
                  System.exit(0);
              default:
                  System.out.println("Invalid choice. Please try again.");
          }
      }
  }
}
----------------------------------------------------------------------
package com.ravi.linked_list;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

public class LinkedListDemo5 {

	public static void main(String[] args) 
	{			
		
		List<String> listOfName = Arrays.asList("Ravi","Rahul","Ankit", "Rahul");
		
		LinkedList<String> list = new LinkedList<>(listOfName); 
		list.forEach(System.out::println);
		
		System.out.println("....................");
		
		ArrayList<String> listOfCity = new ArrayList<>();
		listOfCity.add("Hyderabad");
		listOfCity.add("Bhubneswar");
		listOfCity.add("Kolkata");	
		
		LinkedList<String> cities = new LinkedList<>(listOfCity);
		cities.add("Pune");		
		cities.forEach(System.out::println);
		
		
		System.out.println("....................");
		
		LinkedList<String> fruits = new LinkedList<>();
		fruits.add("Orange");
		fruits.add("Apple");
		fruits.add("Mango");
		
		List<String> synchronizedFruitList = Collections.synchronizedList(fruits);
		synchronizedFruitList.forEach(System.out::println);	
	}
}
----------------------------------------------------------------------
package com.ravi.linked_list;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

record Product(Integer productId, String productName)
{
	
}

public class LinkedListDemo6 {

	public static void main(String[] args)
	{
		List<Product> listOfProduct = new LinkedList<Product>();
		listOfProduct.add(new Product(1, "ApplePhone"));
		listOfProduct.add(new Product(2, "MiPhone"));
		listOfProduct.add(new Product(3, "VivoPhone"));
		
		System.out.println("Is list empty :"+listOfProduct.isEmpty());
		
		Iterator<Product> iterator = listOfProduct.iterator();
		iterator.forEachRemaining(prod -> System.out.println(prod.productName().toUpperCase()));
		
		Product product = listOfProduct.get(2);
        System.out.println(product);
	}

}
======================================================================
Set<E> interface :
-------------------
Set<E> interface :
-------------------
Set interface is the sub interface of Collection available from JDK 1.2V

Set interface never accept duplicate elements, Here internally equals(Object obj) method is working from the respective class.

Set interface does not maintain any order (because internally It does not use Array concept, Actually It uses hashing algorithm) 

On Set interface we can't use ListIterator interface.

Set interface supports all the methods of Collection interface, few more methods were added from java 9v.

Set interface Hierarchy :
--------------------------
Hierarchy is available in the paint diagram [19-FEB]

What is hashing algorithm ?
-------------------------------
Hashing algorithm is a technique through which we can search, insert and delete an element in more efficient way in comparison to our classical indexing approach.

Hashing algorithm, internally uses Hashtable data structute, Hashtable data structure internally uses Bucket data structure.

Here elements are inserted by using hashing algorithm so the time complexity to insert, delete and search an element would be O(1).

It is more efficient than our classical array approach which works on the basis of index.

HashSet<E> [UNORDERED, UNSORTED, NO DUPLICATES]
------------------------------------------------
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Clonabale, Serializable

It is a predefined class available in java.util package under Set interface and introduced from JDK 1.2V.

It is an unsorted and unordered set.  

It accepts hetrogeneous and homogeneous both kind of data.

It uses Hashtable data structure, default capacity is 16 that means 16 buckets will be created internally.

*It uses the hashcode of the object being inserted into the Collection. Using this hashcode it finds the bucket location.

It doesn't contain any duplicate elements as well as It does not maintain any order while iterating the elements from the collection.

It can accept one null value.

HashSet methods are not synchronized.

HashSet is used for fast searching operation.

It has constant performance in all the operations like insert, delete and search.
--------------------------------------------------------------
It contains 4 types of constructors :

1) HashSet hs1 = new HashSet();
    It will create the HashSet Object with default capacity is 16. The default load fator or Fill Ratio is 0.75   (75% of HashSet is filled up then new HashSet Object will be created having double capacity)

2) HashSet hs2 = new HashSet(int initialCapacity);
    will create the HashSet object with user specified capacity.


3) HashSet hs3 = new HashSet(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor(by default load factor is 0.75)

4) HashSet hs4 = new HashSet(Collection c);
    Interconversion of Collection.

-------------------------------------------------------------
//Unsorted, Unordered and no duplicates
import java.util.*;
public class HashSetDemo 
{
 public static void main(String args[])
 { 
	    HashSet<Integer> hs = new HashSet<>();
		hs.add(67); 
		hs.add(89);		
		hs.add(33);
		hs.add(45);
		hs.add(12);
		hs.add(35);	
		hs.add(null);
		
		hs.forEach(num-> System.out.println(num));
	}
}



















































































































 







































































































































































